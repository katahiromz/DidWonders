#ifndef CPARSER_H_
#define CPARSER_H_

// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

#include <cstdlib>
#include <cassert>
#include <vector>

namespace cparser {

enum Token {
    eof,
    T_ADD_ASSIGN,
    T_ALIGNAS,
    T_ALIGNOF,
    T_AND,
    T_AND_ASSIGN,
    T_ARROW,
    T_ASM,
    T_ASSIGN,
    T_ASTERISK,
    T_ATOMIC,
    T_ATTRIBUTE,
    T_AUTO,
    T_BANG,
    T_BOOL,
    T_BREAK,
    T_CASE,
    T_CDECL,
    T_CHAR,
    T_COLON,
    T_COMMA,
    T_COMPLEX,
    T_CONST,
    T_CONSTANT,
    T_CONTINUE,
    T_CPP_COMMENT,
    T_C_COMMENT_BEGIN,
    T_C_COMMENT_END,
    T_DEC,
    T_DECLSPEC,
    T_DEFAULT,
    T_DIV_ASSIGN,
    T_DO,
    T_DOT,
    T_DOUBLE,
    T_ELLIPSIS,
    T_ELSE,
    T_ENUM,
    T_EQUAL,
    T_EXPRESSION,
    T_EXTERN,
    T_FASTCALL,
    T_FLOAT,
    T_FOR,
    T_FORCEINLINE,
    T_GE,
    T_GENERIC,
    T_GNU_EXTENSION,
    T_GOTO,
    T_GT,
    T_IDENTIFIER,
    T_IF,
    T_IMAGINARY,
    T_INC,
    T_INLINE,
    T_INT,
    T_INT128,
    T_INT32,
    T_INT64,
    T_INVALID_CHAR,
    T_LE,
    T_LONG,
    T_LT,
    T_L_AND,
    T_L_BRACE,
    T_L_BRACKET,
    T_L_OR,
    T_L_PAREN,
    T_L_SHIFT,
    T_L_SHIFT_ASSIGN,
    T_MINUS,
    T_MOD_ASSIGN,
    T_MUL_ASSIGN,
    T_NE,
    T_NEWLINE,
    T_NORETURN,
    T_NOTHROW,
    T_OR,
    T_OR_ASSIGN,
    T_PERCENT,
    T_PLUS,
    T_PRAGMA,
    T_PTR32,
    T_PTR64,
    T_QUESTION,
    T_REGISTER,
    T_RESTRICT,
    T_RETURN,
    T_R_BRACE,
    T_R_BRACKET,
    T_R_PAREN,
    T_R_SHIFT,
    T_R_SHIFT_ASSIGN,
    T_SEMICOLON,
    T_SHARP,
    T_SHORT,
    T_SIGNED,
    T_SIZEOF,
    T_SLASH,
    T_STATIC,
    T_STATIC_ASSERT,
    T_STDCALL,
    T_STRING,
    T_STRUCT,
    T_SUB_ASSIGN,
    T_SWITCH,
    T_TAGNAME,
    T_THREAD_LOCAL,
    T_TILDA,
    T_TYPE,
    T_TYPEDEF,
    T_TYPEDEF_NAME,
    T_TYPEDEF_TAG,
    T_UNALIGNED,
    T_UNION,
    T_UNSIGNED,
    T_VECTOR_SIZE,
    T_VOID,
    T_VOLATILE,
    T_W64,
    T_WHILE,
    T_XOR,
    T_XOR_ASSIGN,
};

inline const char* token_label(Token t) {
    static const char* labels[] = {
        "eof",
        "T_ADD_ASSIGN",
        "T_ALIGNAS",
        "T_ALIGNOF",
        "T_AND",
        "T_AND_ASSIGN",
        "T_ARROW",
        "T_ASM",
        "T_ASSIGN",
        "T_ASTERISK",
        "T_ATOMIC",
        "T_ATTRIBUTE",
        "T_AUTO",
        "T_BANG",
        "T_BOOL",
        "T_BREAK",
        "T_CASE",
        "T_CDECL",
        "T_CHAR",
        "T_COLON",
        "T_COMMA",
        "T_COMPLEX",
        "T_CONST",
        "T_CONSTANT",
        "T_CONTINUE",
        "T_CPP_COMMENT",
        "T_C_COMMENT_BEGIN",
        "T_C_COMMENT_END",
        "T_DEC",
        "T_DECLSPEC",
        "T_DEFAULT",
        "T_DIV_ASSIGN",
        "T_DO",
        "T_DOT",
        "T_DOUBLE",
        "T_ELLIPSIS",
        "T_ELSE",
        "T_ENUM",
        "T_EQUAL",
        "T_EXPRESSION",
        "T_EXTERN",
        "T_FASTCALL",
        "T_FLOAT",
        "T_FOR",
        "T_FORCEINLINE",
        "T_GE",
        "T_GENERIC",
        "T_GNU_EXTENSION",
        "T_GOTO",
        "T_GT",
        "T_IDENTIFIER",
        "T_IF",
        "T_IMAGINARY",
        "T_INC",
        "T_INLINE",
        "T_INT",
        "T_INT128",
        "T_INT32",
        "T_INT64",
        "T_INVALID_CHAR",
        "T_LE",
        "T_LONG",
        "T_LT",
        "T_L_AND",
        "T_L_BRACE",
        "T_L_BRACKET",
        "T_L_OR",
        "T_L_PAREN",
        "T_L_SHIFT",
        "T_L_SHIFT_ASSIGN",
        "T_MINUS",
        "T_MOD_ASSIGN",
        "T_MUL_ASSIGN",
        "T_NE",
        "T_NEWLINE",
        "T_NORETURN",
        "T_NOTHROW",
        "T_OR",
        "T_OR_ASSIGN",
        "T_PERCENT",
        "T_PLUS",
        "T_PRAGMA",
        "T_PTR32",
        "T_PTR64",
        "T_QUESTION",
        "T_REGISTER",
        "T_RESTRICT",
        "T_RETURN",
        "T_R_BRACE",
        "T_R_BRACKET",
        "T_R_PAREN",
        "T_R_SHIFT",
        "T_R_SHIFT_ASSIGN",
        "T_SEMICOLON",
        "T_SHARP",
        "T_SHORT",
        "T_SIGNED",
        "T_SIZEOF",
        "T_SLASH",
        "T_STATIC",
        "T_STATIC_ASSERT",
        "T_STDCALL",
        "T_STRING",
        "T_STRUCT",
        "T_SUB_ASSIGN",
        "T_SWITCH",
        "T_TAGNAME",
        "T_THREAD_LOCAL",
        "T_TILDA",
        "T_TYPE",
        "T_TYPEDEF",
        "T_TYPEDEF_NAME",
        "T_TYPEDEF_TAG",
        "T_UNALIGNED",
        "T_UNION",
        "T_UNSIGNED",
        "T_VECTOR_SIZE",
        "T_VOID",
        "T_VOLATILE",
        "T_W64",
        "T_WHILE",
        "T_XOR",
        "T_XOR_ASSIGN",
    };
    return labels[t];
}

template <class T, unsigned int StackSize>
class Stack {
public:
    Stack() { gap_ = 0; }

    void rollback_tmp() {
        gap_ = stack_.size();
        tmp_.clear();
    }

    void commit_tmp() {
        // may throw
        stack_.reserve(gap_ + tmp_.size());
	   
        // expect not to throw
        stack_.erase(stack_.begin()+ gap_, stack_.end());
        stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());
        tmp_.clear();
    }
    bool push(const T& f) {
        if (StackSize != 0 &&
            int(StackSize) <= int(stack_.size() + tmp_.size())) {
            return false;
        }
        tmp_.push_back(f);
        return true;
    }
	   
    void pop(size_t n) {
        if (tmp_.size() < n) {
            n -= tmp_.size();
            tmp_.clear();
            gap_ -= n;
        } else {
            tmp_.erase(tmp_.end() - n, tmp_.end());
        }
    }

    T& top() {
        assert(0 < depth());
        if (!tmp_.empty()) {
            return tmp_.back();
        } else {
            return stack_[gap_ - 1];
        }
    }
	   
    const T& get_arg(size_t base, size_t index) {
        size_t n = tmp_.size();
        if (base - index <= n) {
            return tmp_[n - (base - index)];
        } else {
            return stack_[gap_ - (base - n) + index];
        }
    }
	   
    void clear() {
        stack_.clear();
        tmp_.clear();
        gap_ = 0; 
    }
	   
    bool empty() const {
        if (!tmp_.empty()) {
            return false;
        } else {
            return gap_ == 0;
        }
    }
	   
    size_t depth() const {
        return gap_ + tmp_.size();
    }
	   
    T& nth(size_t index) {
        if (gap_ <= index) {
            return tmp_[index - gap_];
        } else {
            return stack_[index];
        }
    }

    void swap_top_and_second() {
        int d = depth();
        assert(2 <= d);
        T x = nth(d - 1);
        nth(d - 1) = nth(d - 2);
        nth(d - 2) = x;
    }

private:
    std::vector<T> stack_;
    std::vector<T> tmp_;
    size_t gap_;
	   
};

template <class Value, class SemanticAction,
          unsigned int StackSize = 0>
class Parser {
public:
    typedef Token token_type;
    typedef Value value_type;

    enum Nonterminal {
        Nonterminal_abstract_declarator,
        Nonterminal_additive_expression,
        Nonterminal_alignment_specifier,
        Nonterminal_and_expression,
        Nonterminal_argument_expression_list,
        Nonterminal_asm_block,
        Nonterminal_asm_operand,
        Nonterminal_asm_operands,
        Nonterminal_asm_specifier,
        Nonterminal_assignment_expression,
        Nonterminal_asterisk_company,
        Nonterminal_atomic_type_specifier,
        Nonterminal_cast_expression,
        Nonterminal_compound_statement,
        Nonterminal_conditional_expression,
        Nonterminal_constant_expression,
        Nonterminal_declaration,
        Nonterminal_declaration_list,
        Nonterminal_declaration_specifiers,
        Nonterminal_declarator,
        Nonterminal_direct_abstract_declarator,
        Nonterminal_direct_declarator,
        Nonterminal_enum_specifier,
        Nonterminal_enumerator,
        Nonterminal_enumerator_list,
        Nonterminal_equality_expression,
        Nonterminal_exclusive_or_expression,
        Nonterminal_expression,
        Nonterminal_expression_statement,
        Nonterminal_external_declaration,
        Nonterminal_function_definition,
        Nonterminal_function_specifier,
        Nonterminal_generic_assoc_list,
        Nonterminal_generic_association,
        Nonterminal_generic_selection,
        Nonterminal_inclusive_or_expression,
        Nonterminal_init_declarator,
        Nonterminal_init_declarator_list,
        Nonterminal_initializer,
        Nonterminal_initializer_list,
        Nonterminal_iteration_statement,
        Nonterminal_jump_statement,
        Nonterminal_labeled_statement,
        Nonterminal_logical_and_expression,
        Nonterminal_logical_or_expression,
        Nonterminal_multiplicative_expression,
        Nonterminal_parameter_declaration,
        Nonterminal_parameter_list,
        Nonterminal_parameter_type_list,
        Nonterminal_pointer,
        Nonterminal_postfix_expression,
        Nonterminal_primary_expression,
        Nonterminal_relational_expression,
        Nonterminal_selection_statement,
        Nonterminal_shift_expression,
        Nonterminal_specifier_qualifier_list,
        Nonterminal_statement,
        Nonterminal_statement_list,
        Nonterminal_static_assert_declaration,
        Nonterminal_storage_class_specifier,
        Nonterminal_struct_declaration,
        Nonterminal_struct_declaration_list,
        Nonterminal_struct_declarator,
        Nonterminal_struct_declarator_list,
        Nonterminal_struct_specifier,
        Nonterminal_translation_unit,
        Nonterminal_type_name,
        Nonterminal_type_qualifier,
        Nonterminal_type_qualifier_list,
        Nonterminal_type_specifier,
        Nonterminal_typedef_declaration_specifiers,
        Nonterminal_typedef_declarator,
        Nonterminal_typedef_declarator_list,
        Nonterminal_typedef_direct_declarator,
        Nonterminal_unary_expression,
        Nonterminal_union_specifier,
    };

public:
    Parser(SemanticAction& sa) : sa_(sa) { reset(); }

    void reset() {
        error_ = false;
        accepted_ = false;
        clear_stack();
        rollback_tmp_stack();
        if (push_stack(0, value_type())) {
            commit_tmp_stack();
        } else {
            sa_.stack_overflow();
            error_ = true;
        }
    }

    bool post(token_type token, const value_type& value) {
        rollback_tmp_stack();
        error_ = false;
        while ((this->*(stack_top()->entry->state))(token, value))
            ; // may throw
        if (!error_) {
            commit_tmp_stack();
        } else {
            recover(token, value);
        }
        return accepted_ || error_;
    }

    bool accept(value_type& v) {
        assert(accepted_);
        if (error_) { return false; }
        v = accepted_value_;
        return true;
    }

    bool error() { return error_; }

private:
    typedef Parser<Value, SemanticAction, StackSize> self_type;

    typedef bool (self_type::*state_type)(token_type, const value_type&);
    typedef int (self_type::*gotof_type)(Nonterminal);

    bool            accepted_;
    bool            error_;
    value_type      accepted_value_;
    SemanticAction& sa_;

    struct table_entry {
        state_type  state;
        gotof_type  gotof;
        bool        handle_error;
    };

    struct stack_frame {
        const table_entry*  entry;
        value_type          value;
        int                 sequence_length;

        stack_frame(const table_entry* e, const value_type& v, int sl)
            : entry(e), value(v), sequence_length(sl) {}
    };

    Stack<stack_frame, StackSize> stack_;

    bool push_stack(int state_index, const value_type& v, int sl = 0) {
        bool f = stack_.push(stack_frame(entry(state_index), v, sl));
        assert(!error_);
        if (!f) { 
            error_ = true;
            sa_.stack_overflow();
        }
        return f;
    }

    void pop_stack(size_t n) {
        stack_.pop(n);
    }

    stack_frame* stack_top() {
        return &stack_.top();
    }

    const value_type& get_arg(size_t base, size_t index) {
        return stack_.get_arg(base, index).value;
    }

    void clear_stack() {
        stack_.clear();
    }

    void rollback_tmp_stack() {
        stack_.rollback_tmp();
    }

    void commit_tmp_stack() {
        stack_.commit_tmp();
    }

    void recover(Token, const value_type&) {
    }

    bool call_nothing(Nonterminal nonterminal, int base) {
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, value_type());
    }

    bool call_0_DoEnumor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Enumor> r = sa_.DoEnumor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Enumor> r = sa_.DoEnumor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncSpec2(Nonterminal nonterminal, int base) {
        shared_ptr<FuncSpec> r = sa_.DoFuncSpec2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncSpec1(Nonterminal nonterminal, int base) {
        shared_ptr<FuncSpec> r = sa_.DoFuncSpec1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncSpec3(Nonterminal nonterminal, int base) {
        shared_ptr<FuncSpec> r = sa_.DoFuncSpec3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCompStmt1(Nonterminal nonterminal, int base) {
        shared_ptr<CompStmt> r = sa_.DoCompStmt1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCompStmt2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<DeclList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CompStmt> r = sa_.DoCompStmt2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCompStmt4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<StmtList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CompStmt> r = sa_.DoCompStmt4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCompStmt3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<StmtList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CompStmt> r = sa_.DoCompStmt3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAlignSpec2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> r = sa_.DoAlignSpec2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAlignSpec1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> r = sa_.DoAlignSpec1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Pointers> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoDeclor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAddExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AddExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<MulExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AddExpr> r = sa_.DoAddExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAddExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AddExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<MulExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AddExpr> r = sa_.DoAddExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAddExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<MulExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AddExpr> r = sa_.DoAddExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAndExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AndExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<EqualExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AndExpr> r = sa_.DoAndExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAndExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<EqualExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AndExpr> r = sa_.DoAndExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmBlock1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AsmOperands> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmBlock> r = sa_.DoAsmBlock1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAtomicTypeSpec1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AtomicTypeSpec> r = sa_.DoAtomicTypeSpec1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> r = sa_.DoDeclList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Decl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclList> r = sa_.DoDeclList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExclOrExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AndExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExclOrExpr> r = sa_.DoExclOrExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExclOrExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<ExclOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AndExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<ExclOrExpr> r = sa_.DoExclOrExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Expr> r = sa_.DoExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AssignExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> r = sa_.DoExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr6(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr6(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr10(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr10(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr8(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr8(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr12(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr12(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr9(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr9(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr7(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr7(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAssignExpr11(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AssignExpr> r = sa_.DoAssignExpr11(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumSpec3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<EnumorList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoEnumSpec3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumSpec4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<EnumorList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoEnumSpec4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumSpec5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoEnumSpec5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumSpec1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<EnumorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoEnumSpec1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumSpec2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<EnumorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoEnumSpec2(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCondExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<LogOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> r = sa_.DoCondExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCondExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<LogOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CondExpr> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<CondExpr> r = sa_.DoCondExpr2(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmSpec4(Nonterminal nonterminal, int base) {
        shared_ptr<AsmSpec> r = sa_.DoAsmSpec4();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmSpec3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AsmOperands> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmSpec> r = sa_.DoAsmSpec3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmSpec2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeQualList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmSpec> r = sa_.DoAsmSpec2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmSpec1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeQualList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperands> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AsmSpec> r = sa_.DoAsmSpec1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAbsDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoAbsDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAbsDeclor3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Pointers> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoAbsDeclor3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAbsDeclor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Pointers> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoAbsDeclor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl7a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoDecl7a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl1a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<DeclorList> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<Decl> r = sa_.DoDecl1a(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl7(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoDecl7(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoDecl1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl1v(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<CR_TokenNode> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<Decl> r = sa_.DoDecl1v(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl3a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AlignSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoDecl3a(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl2a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<AlignSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoDecl2a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AsmBlock> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoDecl6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AsmSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoDecl5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoDecl3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclorList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoDecl2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDecl4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<StaticAssertDecl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoDecl4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor2(Nonterminal nonterminal, int base) {
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor6(Nonterminal nonterminal, int base) {
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor6();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor8(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ParamList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor8(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor7(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor7(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirAbsDeclor9(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoDirAbsDeclor9(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumorList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Enumor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<EnumorList> r = sa_.DoEnumorList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEnumorList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<EnumorList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Enumor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<EnumorList> r = sa_.DoEnumorList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAstCom6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AstCom> r = sa_.DoAstCom6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAstCom5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AstCom> r = sa_.DoAstCom5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAstCom4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AstCom> r = sa_.DoAstCom4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand4(Nonterminal nonterminal, int base) {
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand4();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand3(Nonterminal nonterminal, int base) {
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperand1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperand> r = sa_.DoAsmOperand1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperands2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AsmOperand> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperands> r = sa_.DoAsmOperands2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoAsmOperands1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AsmOperands> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AsmOperand> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<AsmOperands> r = sa_.DoAsmOperands1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCastExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<IniterList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CastExpr> r = sa_.DoCastExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCastExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<IniterList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CastExpr> r = sa_.DoCastExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCastExpr4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CastExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CastExpr> r = sa_.DoCastExpr4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoCastExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CastExpr> r = sa_.DoCastExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoConstExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> r = sa_.DoConstExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<FuncSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<FuncSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<StorClsSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<StorClsSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs8(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs8(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDeclSpecs7(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoDeclSpecs7(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirDeclor1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirDeclor4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoDirDeclor3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor7(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoDirDeclor7(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoDirDeclor5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoDirDeclor5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEqualExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<EqualExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<RelExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<EqualExpr> r = sa_.DoEqualExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEqualExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<EqualExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<RelExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<EqualExpr> r = sa_.DoEqualExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoEqualExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<RelExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<EqualExpr> r = sa_.DoEqualExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExprStmt1(Nonterminal nonterminal, int base) {
        shared_ptr<ExprStmt> r = sa_.DoExprStmt1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExprStmt2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExprStmt> r = sa_.DoExprStmt2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoArgExprList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AssignExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ArgExprList> r = sa_.DoArgExprList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoArgExprList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<ArgExprList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<ArgExprList> r = sa_.DoArgExprList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExtDecl3(Nonterminal nonterminal, int base) {
        shared_ptr<ExtDecl> r = sa_.DoExtDecl3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExtDecl2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Decl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExtDecl> r = sa_.DoExtDecl2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoExtDecl1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Decl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExtDecl> r = sa_.DoExtDecl1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncDef4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CompStmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoFuncDef4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncDef3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CompStmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoFuncDef3(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncDef2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CompStmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoFuncDef2(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoFuncDef1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<CompStmt> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<Decl> r = sa_.DoFuncDef1(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> r = sa_.DoStructDeclList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Decl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclList> r = sa_.DoStructDeclList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInitDeclorList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclorList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> r = sa_.DoInitDeclorList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInitDeclorList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclorList> r = sa_.DoInitDeclorList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInitDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoInitDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInitDeclor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Initer> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoInitDeclor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Stmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IterStmt> r = sa_.DoIterStmt2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Stmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<IterStmt> r = sa_.DoIterStmt3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IterStmt> r = sa_.DoIterStmt4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IterStmt> r = sa_.DoIterStmt5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt6(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Stmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<IterStmt> r = sa_.DoIterStmt6(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt7(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IterStmt> r = sa_.DoIterStmt7(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt8(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Stmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<IterStmt> r = sa_.DoIterStmt8(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt9(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Stmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<IterStmt> r = sa_.DoIterStmt9(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt10(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Expr> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Stmt> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<IterStmt> r = sa_.DoIterStmt10(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIterStmt1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IterStmt> r = sa_.DoIterStmt1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoShiftExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AddExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ShiftExpr> r = sa_.DoShiftExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoShiftExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<ShiftExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AddExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<ShiftExpr> r = sa_.DoShiftExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoShiftExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<ShiftExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AddExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<ShiftExpr> r = sa_.DoShiftExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr6(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr6(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr8(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr8(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr7(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr7(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Expr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPostfixExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PrimExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PostfixExpr> r = sa_.DoPostfixExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPtr4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AstCom> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Pointers> r = sa_.DoPtr4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPtr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AstCom> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Pointers> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Pointers> r = sa_.DoPtr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPtr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AstCom> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeQualList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Pointers> r = sa_.DoPtr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPtr1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<AstCom> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeQualList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Pointers> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Pointers> r = sa_.DoPtr1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoMulExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<MulExpr> r = sa_.DoMulExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoMulExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<MulExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CastExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<MulExpr> r = sa_.DoMulExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoMulExpr4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<MulExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CastExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<MulExpr> r = sa_.DoMulExpr4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoMulExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<MulExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CastExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<MulExpr> r = sa_.DoMulExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLabeledStmt2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<LabeledStmt> r = sa_.DoLabeledStmt2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLabeledStmt3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Stmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<LabeledStmt> r = sa_.DoLabeledStmt3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLabeledStmt1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<LabeledStmt> r = sa_.DoLabeledStmt1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLogAndExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<LogAndExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<InclOrExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<LogAndExpr> r = sa_.DoLogAndExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLogAndExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<InclOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<LogAndExpr> r = sa_.DoLogAndExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPrimExpr2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PrimExpr> r = sa_.DoPrimExpr2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPrimExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PrimExpr> r = sa_.DoPrimExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPrimExpr4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PrimExpr> r = sa_.DoPrimExpr4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPrimExpr3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<PrimExpr> r = sa_.DoPrimExpr3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoPrimExpr5(Nonterminal nonterminal, int base) {
        shared_ptr<PrimExpr> r = sa_.DoPrimExpr5();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoGeneSel1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AssignExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<GeneAssocList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<GeneSel> r = sa_.DoGeneSel1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLogOrExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<LogAndExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<LogOrExpr> r = sa_.DoLogOrExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoLogOrExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<LogOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<LogAndExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<LogOrExpr> r = sa_.DoLogOrExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<ParamList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<ParamList> r = sa_.DoParamList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Decl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> r = sa_.DoParamList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoGeneAssoc2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AssignExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<GeneAssoc> r = sa_.DoGeneAssoc2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoGeneAssoc1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AssignExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<GeneAssoc> r = sa_.DoGeneAssoc1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSpecQualList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoSpecQualList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSpecQualList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoSpecQualList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSpecQualList4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoSpecQualList4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSpecQualList3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoSpecQualList3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStorClsSpec1(Nonterminal nonterminal, int base) {
        shared_ptr<StorClsSpec> r = sa_.DoStorClsSpec1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStorClsSpec2(Nonterminal nonterminal, int base) {
        shared_ptr<StorClsSpec> r = sa_.DoStorClsSpec2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStorClsSpec3(Nonterminal nonterminal, int base) {
        shared_ptr<StorClsSpec> r = sa_.DoStorClsSpec3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStorClsSpec4(Nonterminal nonterminal, int base) {
        shared_ptr<StorClsSpec> r = sa_.DoStorClsSpec4();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStorClsSpec5(Nonterminal nonterminal, int base) {
        shared_ptr<StorClsSpec> r = sa_.DoStorClsSpec5();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDecl2a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<AlignSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoStructDecl2a(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDecl1a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<AlignSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<Decl> r = sa_.DoStructDecl1a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDecl2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoStructDecl2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDecl1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclorList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoStructDecl1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDecl3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<StaticAssertDecl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoStructDecl3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamDecl3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Decl> r = sa_.DoParamDecl3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamDecl1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoParamDecl1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamDecl2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Decl> r = sa_.DoParamDecl2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIniter2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<IniterList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Initer> r = sa_.DoIniter2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIniter3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<IniterList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Initer> r = sa_.DoIniter3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIniter1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AssignExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Initer> r = sa_.DoIniter1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CompStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ExprStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<IterStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<LabeledStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<SelStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmt6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<JumpStmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> r = sa_.DoStmt6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSelStmt2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<SelStmt> r = sa_.DoSelStmt2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSelStmt1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Stmt> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<SelStmt> r = sa_.DoSelStmt1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoSelStmt3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<SelStmt> r = sa_.DoSelStmt3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmtList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Stmt> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<StmtList> r = sa_.DoStmtList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStmtList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<StmtList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Stmt> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<StmtList> r = sa_.DoStmtList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoGeneAssocList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<GeneAssoc> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<GeneAssocList> r = sa_.DoGeneAssocList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoGeneAssocList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<GeneAssocList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<GeneAssoc> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<GeneAssocList> r = sa_.DoGeneAssocList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStaticAssertDecl1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CondExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<StaticAssertDecl> r = sa_.DoStaticAssertDecl1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoRelExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ShiftExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<RelExpr> r = sa_.DoRelExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoRelExpr5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<RelExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ShiftExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<RelExpr> r = sa_.DoRelExpr5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoRelExpr3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<RelExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ShiftExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<RelExpr> r = sa_.DoRelExpr3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoRelExpr4(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<RelExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ShiftExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<RelExpr> r = sa_.DoRelExpr4(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoRelExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<RelExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ShiftExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<RelExpr> r = sa_.DoRelExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclor3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoStructDeclor3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoStructDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoStructDeclor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIniterList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Initer> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<IniterList> r = sa_.DoIniterList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoIniterList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<IniterList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Initer> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<IniterList> r = sa_.DoIniterList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoJumpStmt3(Nonterminal nonterminal, int base) {
        shared_ptr<JumpStmt> r = sa_.DoJumpStmt3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoJumpStmt2(Nonterminal nonterminal, int base) {
        shared_ptr<JumpStmt> r = sa_.DoJumpStmt2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoJumpStmt1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<JumpStmt> r = sa_.DoJumpStmt1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoJumpStmt4(Nonterminal nonterminal, int base) {
        shared_ptr<JumpStmt> r = sa_.DoJumpStmt4();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoJumpStmt5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<JumpStmt> r = sa_.DoJumpStmt5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamTypeList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ParamList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> r = sa_.DoParamTypeList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoParamTypeList1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ParamList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> r = sa_.DoParamTypeList1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInclOrExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ExclOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<InclOrExpr> r = sa_.DoInclOrExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoInclOrExpr2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<InclOrExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExclOrExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<InclOrExpr> r = sa_.DoInclOrExpr2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclorList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclorList> r = sa_.DoStructDeclorList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructDeclorList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclorList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> r = sa_.DoStructDeclorList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTransUnit3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Expr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TransUnit> r = sa_.DoTransUnit3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTransUnit4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TransUnit> r = sa_.DoTransUnit4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTransUnit2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<ExtDecl> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TransUnit> r = sa_.DoTransUnit2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTransUnit1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TransUnit> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ExtDecl> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TransUnit> r = sa_.DoTransUnit1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec2a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec2a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec3a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CR_TokenNode> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec3a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoStructSpec1a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CR_TokenNode> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<DeclList> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<TypeSpec> r = sa_.DoStructSpec1a(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec12(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec12();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec2(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec19(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec19();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec9(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec9();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec8(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec8();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec20(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec20();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec4(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec4();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec22(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec22();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec5(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec5();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec6(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec6();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec7(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec7();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec3(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec10(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec10();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec14(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec14(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec11(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec11();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec1(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec13(Nonterminal nonterminal, int base) {
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec13();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec18(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<AtomicTypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec18(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec17(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec17(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec15(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec15(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeSpec16(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeSpec> r = sa_.DoTypeSpec16(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclSpecs3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoTypedefDeclSpecs3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclSpecs1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeSpec> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoTypedefDeclSpecs1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclSpecs4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> r = sa_.DoTypedefDeclSpecs4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclSpecs2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclSpecs> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclSpecs> r = sa_.DoTypedefDeclSpecs2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeName2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeName> r = sa_.DoTypeName2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeName1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclSpecs> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeName> r = sa_.DoTypeName1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclor1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Pointers> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoTypedefDeclor1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoTypedefDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclorList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclorList> r = sa_.DoTypedefDeclorList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDeclorList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<DeclorList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclorList> r = sa_.DoTypedefDeclorList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeQual1(Nonterminal nonterminal, int base) {
        shared_ptr<TypeQual> r = sa_.DoTypeQual1();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeQual2(Nonterminal nonterminal, int base) {
        shared_ptr<TypeQual> r = sa_.DoTypeQual2();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeQual3(Nonterminal nonterminal, int base) {
        shared_ptr<TypeQual> r = sa_.DoTypeQual3();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec2(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<DeclList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec2(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CR_TokenNode> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec1(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec2a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<DeclList> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec2a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec3a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CR_TokenNode> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec3a(arg0, arg1, arg2);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnionSpec1a(Nonterminal nonterminal, int base, int arg_index0, int arg_index1, int arg_index2, int arg_index3) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<AlignSpec> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<CR_TokenNode> arg2; sa_.downcast(arg2, get_arg(base, arg_index2));
        shared_ptr<DeclList> arg3; sa_.downcast(arg3, get_arg(base, arg_index3));
        shared_ptr<TypeSpec> r = sa_.DoUnionSpec1a(arg0, arg1, arg2, arg3);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeQualList2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeQual> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeQualList> r = sa_.DoTypeQualList2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypeQualList1(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<TypeQualList> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<TypeQual> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<TypeQualList> r = sa_.DoTypeQualList1(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CR_TokenNode> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor3(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<CondExpr> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor3(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor7(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor7(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoTypedefDirDeclor5(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Declor> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<ParamList> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Declor> r = sa_.DoTypedefDirDeclor5(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr12(Nonterminal nonterminal, int base) {
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr12();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr4(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr4(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr5(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr5(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr9(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr9(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr3(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr3(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr2(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr2(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr7(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr7(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr6(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr6(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr11(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<TypeName> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr11(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr10(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<UnaryExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr10(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr8(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<CastExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr8(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_DoUnaryExpr1(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<PostfixExpr> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<UnaryExpr> r = sa_.DoUnaryExpr1(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool state_0(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXPRESSION:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPE:
            // shift
            push_stack(/*state*/ 7, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_0(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_declarator: return 18;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 11;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_declaration_specifiers: return 13;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_external_declaration: return 3;
        case Nonterminal_function_definition: return 10;
        case Nonterminal_pointer: return 203;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_translation_unit: return 1;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_1(token_type token, const value_type& value) {
        switch(token) {
        case eof:
            // accept
            accepted_ = true;
            accepted_value_ = get_arg(1, 0);
            return false;
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_1(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_declarator: return 18;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 11;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_declaration_specifiers: return 13;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_external_declaration: return 2;
        case Nonterminal_function_definition: return 10;
        case Nonterminal_pointer: return 203;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_2(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTransUnit1(Nonterminal_translation_unit, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_2(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_3(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTransUnit2(Nonterminal_translation_unit, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_3(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_4(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_4(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 5;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_5(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_EXPRESSION:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_5(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_6(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTransUnit3(Nonterminal_translation_unit, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_6(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_7(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_7(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 8;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_8(token_type token, const value_type& value) {
        switch(token) {
        case T_TYPE:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_8(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_9(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTransUnit4(Nonterminal_translation_unit, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_9(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_10(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoExtDecl1(Nonterminal_external_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_10(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_11(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoExtDecl2(Nonterminal_external_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_11(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_12(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoExtDecl3(Nonterminal_external_declaration, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_12(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_13(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_13(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 14;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_init_declarator_list: return 46;
        case Nonterminal_init_declarator: return 157;
        case Nonterminal_pointer: return 203;
        default: assert(0); return false;
        }
    }

    bool state_14(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ASSIGN:
            // shift
            push_stack(/*state*/ 159, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInitDeclor2(Nonterminal_init_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_14(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 17;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_declaration_list: return 15;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 25;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_15(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_15(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 16;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 24;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_16(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncDef1(Nonterminal_function_definition, /*pop*/ 4, 0, 1, 2, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_16(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_17(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncDef2(Nonterminal_function_definition, /*pop*/ 3, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_17(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_18(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_18(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 21;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_declaration_list: return 19;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 25;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_19(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_19(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 20;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 24;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_20(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncDef3(Nonterminal_function_definition, /*pop*/ 3, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_20(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_21(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncDef4(Nonterminal_function_definition, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_21(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_22(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 308, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_22(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_declaration_list: return 23;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 25;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_statement: return 275;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_statement_list: return 272;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_23(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASM:
            // shift
            push_stack(/*state*/ 129, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 309, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_TYPEDEF:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_23(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_alignment_specifier: return 41;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_asm_block: return 53;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_asm_specifier: return 51;
        case Nonterminal_declaration: return 24;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_declaration_specifiers: return 45;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_statement: return 275;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_statement_list: return 273;
        case Nonterminal_static_assert_declaration: return 50;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_24(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDeclList1(Nonterminal_declaration_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_24(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_25(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDeclList2(Nonterminal_declaration_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_25(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_26(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_26(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 27;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 68;
        case Nonterminal_typedef_declaration_specifiers: return 31;
        case Nonterminal_type_qualifier: return 69;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_27(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_27(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 68;
        case Nonterminal_typedef_declaration_specifiers: return 28;
        case Nonterminal_type_qualifier: return 69;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_28(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 197, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case T_TYPEDEF_TAG:
            // shift
            push_stack(/*state*/ 207, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_28(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 198;
        case Nonterminal_typedef_declarator: return 154;
        case Nonterminal_typedef_declarator_list: return 29;
        case Nonterminal_typedef_direct_declarator: return 200;
        default: assert(0); return false;
        }
    }

    bool state_29(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 152, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 30, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_29(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_30(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl1a(Nonterminal_declaration, /*pop*/ 5, 0, 1, 2, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_30(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_31(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 197, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 40, value);
            return false;
        case T_TYPEDEF_TAG:
            // shift
            push_stack(/*state*/ 207, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_31(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 198;
        case Nonterminal_typedef_declarator: return 154;
        case Nonterminal_typedef_declarator_list: return 32;
        case Nonterminal_typedef_direct_declarator: return 200;
        default: assert(0); return false;
        }
    }

    bool state_32(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 152, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 38, value);
            return false;
        case T_VECTOR_SIZE:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_32(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_33(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 34, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_33(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_34(token_type token, const value_type& value) {
        switch(token) {
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 35, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_34(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_35(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 36, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_35(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_36(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 37, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_36(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_37(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl1v(Nonterminal_declaration, /*pop*/ 8, 0, 1, 2, 5);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_37(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_38(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl1(Nonterminal_declaration, /*pop*/ 4, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_38(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_39(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl7a(Nonterminal_declaration, /*pop*/ 4, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_39(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_40(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl7(Nonterminal_declaration, /*pop*/ 3, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_40(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_41(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_41(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 42;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_42(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_42(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 158;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_init_declarator_list: return 43;
        case Nonterminal_init_declarator: return 157;
        case Nonterminal_pointer: return 203;
        default: assert(0); return false;
        }
    }

    bool state_43(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 155, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 44, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_43(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_44(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl2a(Nonterminal_declaration, /*pop*/ 4, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_44(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_45(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_45(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 158;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_init_declarator_list: return 46;
        case Nonterminal_init_declarator: return 157;
        case Nonterminal_pointer: return 203;
        default: assert(0); return false;
        }
    }

    bool state_46(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 155, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 47, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_46(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_47(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl2(Nonterminal_declaration, /*pop*/ 3, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_47(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_48(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl3a(Nonterminal_declaration, /*pop*/ 3, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_48(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_49(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl3(Nonterminal_declaration, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_49(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_50(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl4(Nonterminal_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_50(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_51(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 52, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_51(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_52(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl5(Nonterminal_declaration, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_52(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_53(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoDecl6(Nonterminal_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_53(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_54(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs2(Nonterminal_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_54(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 64;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_55(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs4(Nonterminal_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_55(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 65;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_56(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs6(Nonterminal_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_56(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 66;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_57(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs8(Nonterminal_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_57(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 67;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_58(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 58, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 266, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_58(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_declarator: return 218;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_abstract_declarator: return 256;
        case Nonterminal_direct_abstract_declarator: return 255;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 204;
        case Nonterminal_parameter_list: return 235;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 238;
        case Nonterminal_parameter_type_list: return 268;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_59(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 216, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_59(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_parameter_list: return 235;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 238;
        case Nonterminal_parameter_type_list: return 214;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_60(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 226, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_60(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_parameter_list: return 235;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 238;
        case Nonterminal_parameter_type_list: return 224;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_61(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 61, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 266, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_61(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_abstract_declarator: return 256;
        case Nonterminal_direct_abstract_declarator: return 255;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_pointer: return 253;
        case Nonterminal_parameter_list: return 235;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 238;
        case Nonterminal_parameter_type_list: return 268;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_62(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 267, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_62(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_parameter_list: return 235;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 238;
        case Nonterminal_parameter_type_list: return 270;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_63(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_AUTO:
            // shift
            push_stack(/*state*/ 72, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ELLIPSIS:
            // shift
            push_stack(/*state*/ 236, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_EXTERN:
            // shift
            push_stack(/*state*/ 73, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_FORCEINLINE:
            // shift
            push_stack(/*state*/ 517, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INLINE:
            // shift
            push_stack(/*state*/ 516, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_NORETURN:
            // shift
            push_stack(/*state*/ 518, value);
            return false;
        case T_REGISTER:
            // shift
            push_stack(/*state*/ 74, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC:
            // shift
            push_stack(/*state*/ 75, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_THREAD_LOCAL:
            // shift
            push_stack(/*state*/ 76, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_63(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_function_specifier: return 55;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_declaration_specifiers: return 202;
        case Nonterminal_storage_class_specifier: return 54;
        case Nonterminal_parameter_declaration: return 237;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 56;
        case Nonterminal_type_qualifier: return 57;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_64(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs1(Nonterminal_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_64(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_65(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs3(Nonterminal_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_65(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_66(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs5(Nonterminal_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_66(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_67(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoDeclSpecs7(Nonterminal_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_67(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_68(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_L_PAREN:
        case T_SEMICOLON:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoTypedefDeclSpecs3(Nonterminal_typedef_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_68(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 68;
        case Nonterminal_typedef_declaration_specifiers: return 70;
        case Nonterminal_type_qualifier: return 69;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_69(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_L_PAREN:
        case T_SEMICOLON:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoTypedefDeclSpecs4(Nonterminal_typedef_declaration_specifiers, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_69(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 68;
        case Nonterminal_typedef_declaration_specifiers: return 71;
        case Nonterminal_type_qualifier: return 69;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_70(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_L_PAREN:
        case T_SEMICOLON:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoTypedefDeclSpecs1(Nonterminal_typedef_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_70(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_71(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_L_PAREN:
        case T_SEMICOLON:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoTypedefDeclSpecs2(Nonterminal_typedef_declaration_specifiers, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_71(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_72(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStorClsSpec1(Nonterminal_storage_class_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_72(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_73(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStorClsSpec2(Nonterminal_storage_class_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_73(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_74(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStorClsSpec3(Nonterminal_storage_class_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_74(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_75(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStorClsSpec4(Nonterminal_storage_class_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_75(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_76(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStorClsSpec5(Nonterminal_storage_class_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_76(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_77(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_77(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 125;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_78(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_78(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 79;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_79(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 137, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_79(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_80(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_80(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 81;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_81(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 139, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_81(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_82(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_82(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 83;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_83(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 140, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_83(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_84(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_84(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 85;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_85(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 141, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_85(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_86(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_86(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 87;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_87(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 145, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_87(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_88(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_88(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 89;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_89(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 147, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_89(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_90(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_90(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 91;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_91(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 148, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_91(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_92(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_92(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_struct_declaration_list: return 93;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 151;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_93(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 149, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STATIC_ASSERT:
            // shift
            push_stack(/*state*/ 524, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_93(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 94;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 164;
        case Nonterminal_struct_declaration: return 150;
        case Nonterminal_static_assert_declaration: return 169;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_94(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_94(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 161;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_95(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COLON:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_TYPE:
            // reduce
            return call_0_DoSpecQualList2(Nonterminal_specifier_qualifier_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_95(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 170;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_96(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        case T_ASTERISK:
        case T_COLON:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_TYPE:
            // reduce
            return call_0_DoSpecQualList4(Nonterminal_specifier_qualifier_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_96(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 171;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_97(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_97(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 373;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 466;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_98(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_98(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 373;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 483;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_99(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_99(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 522;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 520;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_100(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_100(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 486;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_101(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 512, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_101(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_generic_association: return 509;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_generic_assoc_list: return 506;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 510;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_102(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
            // shift
            push_stack(/*state*/ 124, value);
            return false;
        case T_BOOL:
            // shift
            push_stack(/*state*/ 115, value);
            return false;
        case T_CHAR:
            // shift
            push_stack(/*state*/ 104, value);
            return false;
        case T_COMPLEX:
            // shift
            push_stack(/*state*/ 122, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 512, value);
            return false;
        case T_DOUBLE:
            // shift
            push_stack(/*state*/ 112, value);
            return false;
        case T_ENUM:
            // shift
            push_stack(/*state*/ 180, value);
            return false;
        case T_FLOAT:
            // shift
            push_stack(/*state*/ 111, value);
            return false;
        case T_IMAGINARY:
            // shift
            push_stack(/*state*/ 123, value);
            return false;
        case T_INT:
            // shift
            push_stack(/*state*/ 106, value);
            return false;
        case T_INT128:
            // shift
            push_stack(/*state*/ 109, value);
            return false;
        case T_INT32:
            // shift
            push_stack(/*state*/ 107, value);
            return false;
        case T_INT64:
            // shift
            push_stack(/*state*/ 108, value);
            return false;
        case T_LONG:
            // shift
            push_stack(/*state*/ 110, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_SHORT:
            // shift
            push_stack(/*state*/ 105, value);
            return false;
        case T_SIGNED:
            // shift
            push_stack(/*state*/ 113, value);
            return false;
        case T_STRUCT:
            // shift
            push_stack(/*state*/ 134, value);
            return false;
        case T_TYPEDEF_NAME:
            // shift
            push_stack(/*state*/ 117, value);
            return false;
        case T_UNION:
            // shift
            push_stack(/*state*/ 142, value);
            return false;
        case T_UNSIGNED:
            // shift
            push_stack(/*state*/ 114, value);
            return false;
        case T_VOID:
            // shift
            push_stack(/*state*/ 103, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_W64:
            // shift
            push_stack(/*state*/ 116, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_102(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_atomic_type_specifier: return 121;
        case Nonterminal_enum_specifier: return 120;
        case Nonterminal_generic_association: return 508;
        case Nonterminal_specifier_qualifier_list: return 227;
        case Nonterminal_struct_specifier: return 118;
        case Nonterminal_type_specifier: return 95;
        case Nonterminal_type_name: return 510;
        case Nonterminal_type_qualifier: return 96;
        case Nonterminal_union_specifier: return 119;
        default: assert(0); return false;
        }
    }

    bool state_103(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec1(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_103(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_104(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec2(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_104(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_105(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec3(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_105(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_106(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec4(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_106(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_107(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec5(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_107(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_108(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec6(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_108(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_109(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec22(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_109(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_110(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec7(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_110(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_111(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec8(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_111(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_112(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec9(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_112(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_113(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec10(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_113(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_114(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec11(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_114(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_115(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec12(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_115(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_116(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec13(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_116(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_117(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec14(Nonterminal_type_specifier, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_117(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_118(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec15(Nonterminal_type_specifier, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_118(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_119(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec16(Nonterminal_type_specifier, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_119(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_120(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec17(Nonterminal_type_specifier, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_120(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_121(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec18(Nonterminal_type_specifier, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_121(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_122(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec19(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_122(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_123(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeSpec20(Nonterminal_type_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_123(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_124(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 77, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_124(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_125(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 126, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_125(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_126(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoAtomicTypeSpec1(Nonterminal_atomic_type_specifier, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_126(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_127(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoPtr4(Nonterminal_pointer, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_127(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 229;
        case Nonterminal_type_qualifier: return 234;
        case Nonterminal_type_qualifier_list: return 128;
        default: assert(0); return false;
        }
    }

    bool state_128(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoPtr2(Nonterminal_pointer, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_128(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 228;
        case Nonterminal_type_qualifier: return 233;
        default: assert(0); return false;
        }
    }

    bool state_129(token_type token, const value_type& value) {
        switch(token) {
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 538, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 534, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_129(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_type_qualifier: return 234;
        case Nonterminal_type_qualifier_list: return 130;
        default: assert(0); return false;
        }
    }

    bool state_130(token_type token, const value_type& value) {
        switch(token) {
        case T_CONST:
            // shift
            push_stack(/*state*/ 131, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 530, value);
            return false;
        case T_RESTRICT:
            // shift
            push_stack(/*state*/ 132, value);
            return false;
        case T_VOLATILE:
            // shift
            push_stack(/*state*/ 133, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_130(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_type_qualifier: return 233;
        default: assert(0); return false;
        }
    }

    bool state_131(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeQual1(Nonterminal_type_qualifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_131(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_132(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeQual2(Nonterminal_type_qualifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_132(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_133(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoTypeQual3(Nonterminal_type_qualifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_133(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_134(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 84, value);
            return false;
        case T_TAGNAME:
            // shift
            push_stack(/*state*/ 138, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_134(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 135;
        default: assert(0); return false;
        }
    }

    bool state_135(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 82, value);
            return false;
        case T_TAGNAME:
            // shift
            push_stack(/*state*/ 136, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_135(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_136(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 78, value);
            return false;
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec3a(Nonterminal_struct_specifier, /*pop*/ 3, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_136(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_137(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec1a(Nonterminal_struct_specifier, /*pop*/ 6, 0, 1, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_137(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_138(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 80, value);
            return false;
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec3(Nonterminal_struct_specifier, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_138(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_139(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec1(Nonterminal_struct_specifier, /*pop*/ 5, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_139(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_140(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec2a(Nonterminal_struct_specifier, /*pop*/ 5, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_140(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_141(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructSpec2(Nonterminal_struct_specifier, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_141(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_142(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
            // shift
            push_stack(/*state*/ 519, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 92, value);
            return false;
        case T_TAGNAME:
            // shift
            push_stack(/*state*/ 146, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_142(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_alignment_specifier: return 143;
        default: assert(0); return false;
        }
    }

    bool state_143(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 90, value);
            return false;
        case T_TAGNAME:
            // shift
            push_stack(/*state*/ 144, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_143(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_144(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 86, value);
            return false;
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec3a(Nonterminal_union_specifier, /*pop*/ 3, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_144(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_145(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec1a(Nonterminal_union_specifier, /*pop*/ 6, 0, 1, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_145(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_146(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 88, value);
            return false;
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec3(Nonterminal_union_specifier, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_146(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_147(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec1(Nonterminal_union_specifier, /*pop*/ 5, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_147(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_148(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec2a(Nonterminal_union_specifier, /*pop*/ 5, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_148(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_149(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoUnionSpec2(Nonterminal_union_specifier, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_149(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_150(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDeclList1(Nonterminal_struct_declaration_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_150(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_151(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDeclList2(Nonterminal_struct_declaration_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_151(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_152(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 197, value);
            return false;
        case T_TYPEDEF_TAG:
            // shift
            push_stack(/*state*/ 207, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_152(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 198;
        case Nonterminal_typedef_declarator: return 153;
        case Nonterminal_typedef_direct_declarator: return 200;
        default: assert(0); return false;
        }
    }

    bool state_153(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDeclorList1(Nonterminal_typedef_declarator_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_153(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_154(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDeclorList2(Nonterminal_typedef_declarator_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_154(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_155(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_155(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 158;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_init_declarator: return 156;
        case Nonterminal_pointer: return 203;
        default: assert(0); return false;
        }
    }

    bool state_156(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInitDeclorList1(Nonterminal_init_declarator_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_156(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_157(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInitDeclorList2(Nonterminal_init_declarator_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_157(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_158(token_type token, const value_type& value) {
        switch(token) {
        case T_ASSIGN:
            // shift
            push_stack(/*state*/ 159, value);
            return false;
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInitDeclor2(Nonterminal_init_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_158(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_159(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 241, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_159(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 245;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_initializer: return 160;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_160(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInitDeclor1(Nonterminal_init_declarator, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_160(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_161(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_COLON:
            // shift
            push_stack(/*state*/ 178, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 167, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_161(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 175;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 203;
        case Nonterminal_struct_declarator: return 174;
        case Nonterminal_struct_declarator_list: return 162;
        default: assert(0); return false;
        }
    }

    bool state_162(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 172, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 163, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_162(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_163(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDecl1a(Nonterminal_struct_declaration, /*pop*/ 4, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_163(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_164(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_COLON:
            // shift
            push_stack(/*state*/ 178, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 168, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_164(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 175;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 203;
        case Nonterminal_struct_declarator: return 174;
        case Nonterminal_struct_declarator_list: return 165;
        default: assert(0); return false;
        }
    }

    bool state_165(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 172, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 166, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_165(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_166(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDecl1(Nonterminal_struct_declaration, /*pop*/ 3, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_166(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_167(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDecl2a(Nonterminal_struct_declaration, /*pop*/ 3, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_167(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_168(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDecl2(Nonterminal_struct_declaration, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_168(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_169(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ATOMIC:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_FLOAT:
        case T_IMAGINARY:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_RESTRICT:
        case T_R_BRACE:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoStructDecl3(Nonterminal_struct_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_169(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_170(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_TYPE:
            // reduce
            return call_0_DoSpecQualList1(Nonterminal_specifier_qualifier_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_170(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_171(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_TYPE:
            // reduce
            return call_0_DoSpecQualList3(Nonterminal_specifier_qualifier_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_171(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_172(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_COLON:
            // shift
            push_stack(/*state*/ 178, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_172(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 175;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 203;
        case Nonterminal_struct_declarator: return 173;
        default: assert(0); return false;
        }
    }

    bool state_173(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoStructDeclorList1(Nonterminal_struct_declarator_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_173(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_174(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoStructDeclorList2(Nonterminal_struct_declarator_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_174(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_175(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 176, value);
            return false;
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoStructDeclor2(Nonterminal_struct_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_175(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_176(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_176(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 177;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_177(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoStructDeclor1(Nonterminal_struct_declarator, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_177(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_178(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_178(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 179;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_179(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_SEMICOLON:
            // reduce
            return call_0_DoStructDeclor3(Nonterminal_struct_declarator, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_179(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_180(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 187, value);
            return false;
        case T_TAGNAME:
            // shift
            push_stack(/*state*/ 181, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_180(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_181(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 182, value);
            return false;
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoEnumSpec5(Nonterminal_enum_specifier, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_181(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_182(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 194, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_182(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_enumerator: return 193;
        case Nonterminal_enumerator_list: return 183;
        default: assert(0); return false;
        }
    }

    bool state_183(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 184, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 186, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_183(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_184(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 194, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 185, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_184(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_enumerator: return 192;
        default: assert(0); return false;
        }
    }

    bool state_185(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoEnumSpec1(Nonterminal_enum_specifier, /*pop*/ 6, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_185(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_186(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoEnumSpec2(Nonterminal_enum_specifier, /*pop*/ 5, 0, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_186(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_187(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 194, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_187(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_enumerator: return 193;
        case Nonterminal_enumerator_list: return 188;
        default: assert(0); return false;
        }
    }

    bool state_188(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 189, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 191, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_188(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_189(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 194, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 190, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_189(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_enumerator: return 192;
        default: assert(0); return false;
        }
    }

    bool state_190(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoEnumSpec3(Nonterminal_enum_specifier, /*pop*/ 5, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_190(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_191(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPE:
        case T_TYPEDEF_NAME:
        case T_TYPEDEF_TAG:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoEnumSpec4(Nonterminal_enum_specifier, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_191(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_192(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoEnumorList1(Nonterminal_enumerator_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_192(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_193(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoEnumorList2(Nonterminal_enumerator_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_193(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_194(token_type token, const value_type& value) {
        switch(token) {
        case T_ASSIGN:
            // shift
            push_stack(/*state*/ 195, value);
            return false;
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoEnumor2(Nonterminal_enumerator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_194(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_195(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_195(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 196;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_196(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoEnumor1(Nonterminal_enumerator, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_196(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_197(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 197, value);
            return false;
        case T_TYPEDEF_TAG:
            // shift
            push_stack(/*state*/ 207, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_197(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 198;
        case Nonterminal_typedef_declarator: return 208;
        case Nonterminal_typedef_direct_declarator: return 200;
        default: assert(0); return false;
        }
    }

    bool state_198(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 197, value);
            return false;
        case T_TYPEDEF_TAG:
            // shift
            push_stack(/*state*/ 207, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_198(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_typedef_direct_declarator: return 199;
        default: assert(0); return false;
        }
    }

    bool state_199(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 210, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 59, value);
            return false;
        case T_COMMA:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDeclor1(Nonterminal_typedef_declarator, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_199(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_200(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 210, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 59, value);
            return false;
        case T_COMMA:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDeclor2(Nonterminal_typedef_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_200(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_201(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_201(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 218;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 203;
        default: assert(0); return false;
        }
    }

    bool state_202(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 58, value);
            return false;
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoParamDecl3(Nonterminal_parameter_declaration, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_202(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_declarator: return 239;
        case Nonterminal_abstract_declarator: return 240;
        case Nonterminal_direct_abstract_declarator: return 255;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_direct_declarator: return 206;
        case Nonterminal_pointer: return 204;
        default: assert(0); return false;
        }
    }

    bool state_203(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 201, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_203(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_direct_declarator: return 205;
        default: assert(0); return false;
        }
    }

    bool state_204(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 217, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 58, value);
            return false;
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoAbsDeclor3(Nonterminal_abstract_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_204(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_direct_abstract_declarator: return 254;
        case Nonterminal_direct_declarator: return 205;
        default: assert(0); return false;
        }
    }

    bool state_205(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 220, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 60, value);
            return false;
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDeclor1(Nonterminal_declarator, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_205(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_206(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 220, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 60, value);
            return false;
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDeclor2(Nonterminal_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_206(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_207(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor1(Nonterminal_typedef_direct_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_207(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_208(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 209, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_208(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_209(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor2(Nonterminal_typedef_direct_declarator, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_209(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_210(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 213, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_210(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 211;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_211(token_type token, const value_type& value) {
        switch(token) {
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 212, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_211(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_212(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor3(Nonterminal_typedef_direct_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_212(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_213(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor4(Nonterminal_typedef_direct_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_213(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_214(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 215, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_214(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_215(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor5(Nonterminal_typedef_direct_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_215(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_216(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_VECTOR_SIZE:
            // reduce
            return call_0_DoTypedefDirDeclor7(Nonterminal_typedef_direct_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_216(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_217(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor1(Nonterminal_direct_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_217(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_218(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 219, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_218(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_219(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor2(Nonterminal_direct_declarator, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_219(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_220(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 223, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_220(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 221;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_221(token_type token, const value_type& value) {
        switch(token) {
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 222, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_221(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_222(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor3(Nonterminal_direct_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_222(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_223(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor4(Nonterminal_direct_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_223(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_224(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 225, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_224(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_225(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor5(Nonterminal_direct_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_225(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_226(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNAS:
        case T_ASM:
        case T_ASSIGN:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COLON:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoDirDeclor7(Nonterminal_direct_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_226(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_227(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 230, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 61, value);
            return false;
        case T_COLON:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoTypeName2(Nonterminal_type_name, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_227(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_abstract_declarator: return 252;
        case Nonterminal_direct_abstract_declarator: return 255;
        case Nonterminal_asterisk_company: return 127;
        case Nonterminal_pointer: return 253;
        default: assert(0); return false;
        }
    }

    bool state_228(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoPtr1(Nonterminal_pointer, /*pop*/ 3, 0, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_228(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_229(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
            // reduce
            return call_0_DoPtr3(Nonterminal_pointer, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_229(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_230(token_type token, const value_type& value) {
        switch(token) {
        case T_PTR32:
            // shift
            push_stack(/*state*/ 232, value);
            return false;
        case T_PTR64:
            // shift
            push_stack(/*state*/ 231, value);
            return false;
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_CONST:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
        case T_VOLATILE:
            // reduce
            return call_0_DoAstCom6(Nonterminal_asterisk_company, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_230(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_231(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_CONST:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
        case T_VOLATILE:
            // reduce
            return call_0_DoAstCom4(Nonterminal_asterisk_company, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_231(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_232(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_CONST:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
        case T_VOLATILE:
            // reduce
            return call_0_DoAstCom5(Nonterminal_asterisk_company, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_232(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_233(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_CONST:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
        case T_VOLATILE:
            // reduce
            return call_0_DoTypeQualList1(Nonterminal_type_qualifier_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_233(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_234(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_CONST:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_TYPE:
        case T_TYPEDEF_TAG:
        case T_VOLATILE:
            // reduce
            return call_0_DoTypeQualList2(Nonterminal_type_qualifier_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_234(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_235(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 63, value);
            return false;
        case T_R_PAREN:
            // reduce
            return call_0_DoParamTypeList2(Nonterminal_parameter_type_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_235(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_236(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // reduce
            return call_0_DoParamTypeList1(Nonterminal_parameter_type_list, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_236(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_237(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoParamList1(Nonterminal_parameter_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_237(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_238(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoParamList2(Nonterminal_parameter_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_238(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_239(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoParamDecl1(Nonterminal_parameter_declaration, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_239(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_240(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoParamDecl2(Nonterminal_parameter_declaration, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_240(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_241(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 241, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_241(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 245;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_initializer: return 251;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_initializer_list: return 246;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_242(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 241, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 247, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_242(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 245;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_initializer: return 250;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_243(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 241, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_243(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 245;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_initializer: return 251;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_initializer_list: return 249;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_244(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 241, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 467, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_244(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 245;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_initializer: return 250;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_245(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
        case T_SEMICOLON:
            // reduce
            return call_0_DoIniter1(Nonterminal_initializer, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_245(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_246(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 242, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 248, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_246(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_247(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
        case T_SEMICOLON:
            // reduce
            return call_0_DoIniter2(Nonterminal_initializer, /*pop*/ 4, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_247(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_248(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
        case T_SEMICOLON:
            // reduce
            return call_0_DoIniter3(Nonterminal_initializer, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_248(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_249(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 244, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 468, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_249(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_250(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoIniterList1(Nonterminal_initializer_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_250(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_251(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_BRACE:
            // reduce
            return call_0_DoIniterList2(Nonterminal_initializer_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_251(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_252(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoTypeName1(Nonterminal_type_name, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_252(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_253(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 258, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 61, value);
            return false;
        case T_COLON:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoAbsDeclor3(Nonterminal_abstract_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_253(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_direct_abstract_declarator: return 254;
        default: assert(0); return false;
        }
    }

    bool state_254(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 260, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 62, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoAbsDeclor1(Nonterminal_abstract_declarator, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_254(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_255(token_type token, const value_type& value) {
        switch(token) {
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 260, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 62, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoAbsDeclor2(Nonterminal_abstract_declarator, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_255(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_256(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 257, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_256(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_257(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor1(Nonterminal_direct_abstract_declarator, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_257(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_258(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 259, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_258(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 262;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_259(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor2(Nonterminal_direct_abstract_declarator, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_259(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_260(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 261, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_260(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 264;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_261(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor3(Nonterminal_direct_abstract_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_261(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_262(token_type token, const value_type& value) {
        switch(token) {
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 263, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_262(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_263(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor4(Nonterminal_direct_abstract_declarator, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_263(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_264(token_type token, const value_type& value) {
        switch(token) {
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 265, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_264(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_265(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor5(Nonterminal_direct_abstract_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_265(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_266(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor6(Nonterminal_direct_abstract_declarator, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_266(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_267(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor7(Nonterminal_direct_abstract_declarator, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_267(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_268(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 269, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_268(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_269(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor8(Nonterminal_direct_abstract_declarator, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_269(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_270(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 271, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_270(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_271(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_PAREN:
        case T_TYPE:
            // reduce
            return call_0_DoDirAbsDeclor9(Nonterminal_direct_abstract_declarator, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_271(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_272(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 310, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_272(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 274;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_273(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 311, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_273(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 274;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_274(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmtList1(Nonterminal_statement_list, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_274(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_275(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmtList2(Nonterminal_statement_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_275(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_276(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_276(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 299;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_277(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_277(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 302;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_278(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_278(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 304;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_279(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_279(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 315;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_280(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_280(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 316;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_281(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_281(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 320;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_282(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_282(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 324;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_283(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_283(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 325;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_284(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_284(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 335;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_285(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_285(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 337;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_286(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_286(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 340;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_287(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_287(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 342;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_288(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_288(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 346;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_289(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_289(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 348;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_290(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_290(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 351;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_291(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_BREAK:
            // shift
            push_stack(/*state*/ 359, value);
            return false;
        case T_CASE:
            // shift
            push_stack(/*state*/ 300, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_CONTINUE:
            // shift
            push_stack(/*state*/ 357, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_DEFAULT:
            // shift
            push_stack(/*state*/ 303, value);
            return false;
        case T_DO:
            // shift
            push_stack(/*state*/ 283, value);
            return false;
        case T_FOR:
            // shift
            push_stack(/*state*/ 331, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_GOTO:
            // shift
            push_stack(/*state*/ 354, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 298, value);
            return false;
        case T_IF:
            // shift
            push_stack(/*state*/ 312, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 22, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_RETURN:
            // shift
            push_stack(/*state*/ 361, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 305, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_SWITCH:
            // shift
            push_stack(/*state*/ 317, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        case T_WHILE:
            // shift
            push_stack(/*state*/ 321, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_291(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_compound_statement: return 294;
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 306;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_expression_statement: return 293;
        case Nonterminal_iteration_statement: return 296;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_labeled_statement: return 292;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_statement: return 353;
        case Nonterminal_selection_statement: return 295;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_jump_statement: return 297;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_292(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt1(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_292(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_293(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt2(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_293(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_294(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt3(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_294(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_295(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt4(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_295(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_296(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt5(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_296(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_297(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoStmt6(Nonterminal_statement, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_297(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_298(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 276, value);
            return false;
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr1(Nonterminal_primary_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_298(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_299(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoLabeledStmt1(Nonterminal_labeled_statement, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_299(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_300(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_300(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 301;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_301(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 277, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_301(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_302(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoLabeledStmt2(Nonterminal_labeled_statement, /*pop*/ 4, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_302(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_303(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 278, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_303(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_304(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoLabeledStmt3(Nonterminal_labeled_statement, /*pop*/ 3, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_304(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_305(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoExprStmt1(Nonterminal_expression_statement, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_305(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_306(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 307, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_306(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_307(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoExprStmt2(Nonterminal_expression_statement, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_307(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_308(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ELSE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoCompStmt1(Nonterminal_compound_statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_308(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_309(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ELSE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoCompStmt2(Nonterminal_compound_statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_309(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_310(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ELSE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoCompStmt3(Nonterminal_compound_statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_310(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_311(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ELSE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoCompStmt4(Nonterminal_compound_statement, /*pop*/ 4, 1, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_311(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_312(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 313, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_312(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_313(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_313(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 314;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_314(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 279, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_314(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_315(token_type token, const value_type& value) {
        switch(token) {
        case T_ELSE:
            // shift
            push_stack(/*state*/ 280, value);
            return false;
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoSelStmt2(Nonterminal_selection_statement, /*pop*/ 5, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_315(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_316(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoSelStmt1(Nonterminal_selection_statement, /*pop*/ 7, 2, 4, 6);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_316(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_317(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 318, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_317(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_318(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_318(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 319;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_319(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 281, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_319(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_320(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoSelStmt3(Nonterminal_selection_statement, /*pop*/ 5, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_320(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_321(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 322, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_321(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_322(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_322(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 323;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_323(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 282, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_323(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_324(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt1(Nonterminal_iteration_statement, /*pop*/ 5, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_324(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_325(token_type token, const value_type& value) {
        switch(token) {
        case T_WHILE:
            // shift
            push_stack(/*state*/ 326, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_325(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_326(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 327, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_326(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_327(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_327(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 328;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_328(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 329, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_328(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_329(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 330, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_329(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_330(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt2(Nonterminal_iteration_statement, /*pop*/ 7, 1, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_330(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_331(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 332, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_331(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_332(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 333, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_332(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 343;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_333(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 334, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_333(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 338;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_334(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 284, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_334(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 336;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_335(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt3(Nonterminal_iteration_statement, /*pop*/ 6, 5);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_335(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_336(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 285, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_336(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_337(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt4(Nonterminal_iteration_statement, /*pop*/ 7, 4, 6);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_337(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_338(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 339, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_338(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_339(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 286, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_339(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 341;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_340(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt5(Nonterminal_iteration_statement, /*pop*/ 7, 3, 6);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_340(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_341(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 287, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_341(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_342(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt6(Nonterminal_iteration_statement, /*pop*/ 8, 3, 5, 7);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_342(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_343(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 344, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_343(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_344(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 345, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_344(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 349;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_345(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 288, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_345(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 347;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_346(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt7(Nonterminal_iteration_statement, /*pop*/ 7, 2, 6);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_346(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_347(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 289, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_347(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_348(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt8(Nonterminal_iteration_statement, /*pop*/ 8, 2, 5, 7);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_348(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_349(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 350, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_349(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_350(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 290, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_350(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 352;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_351(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt9(Nonterminal_iteration_statement, /*pop*/ 8, 2, 4, 7);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_351(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_352(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 291, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_352(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_353(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoIterStmt10(Nonterminal_iteration_statement, /*pop*/ 9, 2, 4, 6, 8);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_353(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_354(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 355, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_354(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_355(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 356, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_355(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_356(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoJumpStmt1(Nonterminal_jump_statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_356(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_357(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 358, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_357(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_358(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoJumpStmt2(Nonterminal_jump_statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_358(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_359(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 360, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_359(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_360(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoJumpStmt3(Nonterminal_jump_statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_360(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_361(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 362, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_361(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 363;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_362(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoJumpStmt4(Nonterminal_jump_statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_362(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_363(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 364, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_363(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_364(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
        case T_AND:
        case T_ASTERISK:
        case T_BANG:
        case T_BREAK:
        case T_CASE:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_ELSE:
        case T_FOR:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_INC:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_PLUS:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SIZEOF:
        case T_STRING:
        case T_SWITCH:
        case T_TILDA:
        case T_WHILE:
            // reduce
            return call_0_DoJumpStmt5(Nonterminal_jump_statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_364(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_365(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_365(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 371;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_366(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_366(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 372;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_367(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_367(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 373;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_368(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_368(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 374;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_369(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_369(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_expression: return 375;
        case Nonterminal_assignment_expression: return 370;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_370(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoExpr1(Nonterminal_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_370(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_371(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 407, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_371(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_372(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 489, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_372(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_373(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 502, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_373(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_374(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 547, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_374(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_375(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 376, value);
            return false;
        case T_R_BRACKET:
            // shift
            push_stack(/*state*/ 548, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_375(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_376(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_376(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 377;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_377(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoExpr2(Nonterminal_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_377(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_378(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_378(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 396;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_379(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_379(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 397;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_380(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_380(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 398;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_381(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_381(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 399;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_382(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_382(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 400;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_383(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_383(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 401;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_384(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_384(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 402;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_385(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_385(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 403;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_386(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_386(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 404;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_387(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_387(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 405;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_388(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_388(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 406;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_389(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 492, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_389(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 515;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_argument_expression_list: return 490;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_390(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_390(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 505;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_391(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_391(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 511;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_392(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_392(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 513;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_393(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_393(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_assignment_expression: return 514;
        case Nonterminal_conditional_expression: return 394;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 395;
        default: assert(0); return false;
        }
    }

    bool state_394(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr1(Nonterminal_assignment_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_394(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_395(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
            // shift
            push_stack(/*state*/ 382, value);
            return false;
        case T_AND_ASSIGN:
            // shift
            push_stack(/*state*/ 386, value);
            return false;
        case T_ASSIGN:
            // shift
            push_stack(/*state*/ 378, value);
            return false;
        case T_DIV_ASSIGN:
            // shift
            push_stack(/*state*/ 380, value);
            return false;
        case T_L_SHIFT_ASSIGN:
            // shift
            push_stack(/*state*/ 384, value);
            return false;
        case T_MOD_ASSIGN:
            // shift
            push_stack(/*state*/ 381, value);
            return false;
        case T_MUL_ASSIGN:
            // shift
            push_stack(/*state*/ 379, value);
            return false;
        case T_OR_ASSIGN:
            // shift
            push_stack(/*state*/ 388, value);
            return false;
        case T_R_SHIFT_ASSIGN:
            // shift
            push_stack(/*state*/ 385, value);
            return false;
        case T_SUB_ASSIGN:
            // shift
            push_stack(/*state*/ 383, value);
            return false;
        case T_XOR_ASSIGN:
            // shift
            push_stack(/*state*/ 387, value);
            return false;
        case T_AND:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_SLASH:
        case T_XOR:
            // reduce
            return call_0_DoCastExpr1(Nonterminal_cast_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_395(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_396(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr2(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_396(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_397(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr3(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_397(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_398(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr4(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_398(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_399(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr5(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_399(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_400(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr6(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_400(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_401(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr7(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_401(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_402(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr8(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_402(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_403(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr9(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_403(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_404(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr10(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_404(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_405(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr11(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_405(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_406(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoAssignExpr12(Nonterminal_assignment_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_406(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_407(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_407(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 410;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_408(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_408(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_conditional_expression: return 411;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_constant_expression: return 525;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 412;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_logical_or_expression: return 409;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_409(token_type token, const value_type& value) {
        switch(token) {
        case T_L_OR:
            // shift
            push_stack(/*state*/ 413, value);
            return false;
        case T_QUESTION:
            // shift
            push_stack(/*state*/ 365, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoCondExpr1(Nonterminal_conditional_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_409(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_410(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoCondExpr2(Nonterminal_conditional_expression, /*pop*/ 5, 0, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_410(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_411(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoConstExpr1(Nonterminal_constant_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_411(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_412(token_type token, const value_type& value) {
        switch(token) {
        case T_L_AND:
            // shift
            push_stack(/*state*/ 416, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoLogOrExpr1(Nonterminal_logical_or_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_412(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_413(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_413(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_logical_and_expression: return 414;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 415;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_414(token_type token, const value_type& value) {
        switch(token) {
        case T_L_AND:
            // shift
            push_stack(/*state*/ 416, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoLogOrExpr2(Nonterminal_logical_or_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_414(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_415(token_type token, const value_type& value) {
        switch(token) {
        case T_OR:
            // shift
            push_stack(/*state*/ 419, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoLogAndExpr1(Nonterminal_logical_and_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_415(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_416(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_416(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 418;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_inclusive_or_expression: return 417;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_417(token_type token, const value_type& value) {
        switch(token) {
        case T_OR:
            // shift
            push_stack(/*state*/ 419, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoLogAndExpr2(Nonterminal_logical_and_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_417(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_418(token_type token, const value_type& value) {
        switch(token) {
        case T_XOR:
            // shift
            push_stack(/*state*/ 422, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInclOrExpr1(Nonterminal_inclusive_or_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_418(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_419(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_419(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 421;
        case Nonterminal_exclusive_or_expression: return 420;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_420(token_type token, const value_type& value) {
        switch(token) {
        case T_XOR:
            // shift
            push_stack(/*state*/ 422, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
            // reduce
            return call_0_DoInclOrExpr2(Nonterminal_inclusive_or_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_420(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_421(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
            // shift
            push_stack(/*state*/ 425, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoExclOrExpr1(Nonterminal_exclusive_or_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_421(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_422(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_422(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_and_expression: return 423;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 424;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_423(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
            // shift
            push_stack(/*state*/ 425, value);
            return false;
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoExclOrExpr2(Nonterminal_exclusive_or_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_423(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_424(token_type token, const value_type& value) {
        switch(token) {
        case T_EQUAL:
            // shift
            push_stack(/*state*/ 428, value);
            return false;
        case T_NE:
            // shift
            push_stack(/*state*/ 430, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoAndExpr1(Nonterminal_and_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_424(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_425(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_425(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_equality_expression: return 426;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 427;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_426(token_type token, const value_type& value) {
        switch(token) {
        case T_EQUAL:
            // shift
            push_stack(/*state*/ 428, value);
            return false;
        case T_NE:
            // shift
            push_stack(/*state*/ 430, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoAndExpr2(Nonterminal_and_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_426(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_427(token_type token, const value_type& value) {
        switch(token) {
        case T_GE:
            // shift
            push_stack(/*state*/ 439, value);
            return false;
        case T_GT:
            // shift
            push_stack(/*state*/ 435, value);
            return false;
        case T_LE:
            // shift
            push_stack(/*state*/ 437, value);
            return false;
        case T_LT:
            // shift
            push_stack(/*state*/ 433, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoEqualExpr1(Nonterminal_equality_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_427(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_428(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_428(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 429;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_429(token_type token, const value_type& value) {
        switch(token) {
        case T_GE:
            // shift
            push_stack(/*state*/ 439, value);
            return false;
        case T_GT:
            // shift
            push_stack(/*state*/ 435, value);
            return false;
        case T_LE:
            // shift
            push_stack(/*state*/ 437, value);
            return false;
        case T_LT:
            // shift
            push_stack(/*state*/ 433, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoEqualExpr2(Nonterminal_equality_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_429(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_430(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_430(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 432;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_relational_expression: return 431;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_431(token_type token, const value_type& value) {
        switch(token) {
        case T_GE:
            // shift
            push_stack(/*state*/ 439, value);
            return false;
        case T_GT:
            // shift
            push_stack(/*state*/ 435, value);
            return false;
        case T_LE:
            // shift
            push_stack(/*state*/ 437, value);
            return false;
        case T_LT:
            // shift
            push_stack(/*state*/ 433, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoEqualExpr3(Nonterminal_equality_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_431(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_432(token_type token, const value_type& value) {
        switch(token) {
        case T_L_SHIFT:
            // shift
            push_stack(/*state*/ 442, value);
            return false;
        case T_R_SHIFT:
            // shift
            push_stack(/*state*/ 444, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoRelExpr1(Nonterminal_relational_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_432(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_433(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_433(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 434;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_434(token_type token, const value_type& value) {
        switch(token) {
        case T_L_SHIFT:
            // shift
            push_stack(/*state*/ 442, value);
            return false;
        case T_R_SHIFT:
            // shift
            push_stack(/*state*/ 444, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoRelExpr2(Nonterminal_relational_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_434(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_435(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_435(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 436;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_436(token_type token, const value_type& value) {
        switch(token) {
        case T_L_SHIFT:
            // shift
            push_stack(/*state*/ 442, value);
            return false;
        case T_R_SHIFT:
            // shift
            push_stack(/*state*/ 444, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoRelExpr3(Nonterminal_relational_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_436(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_437(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_437(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 438;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_438(token_type token, const value_type& value) {
        switch(token) {
        case T_L_SHIFT:
            // shift
            push_stack(/*state*/ 442, value);
            return false;
        case T_R_SHIFT:
            // shift
            push_stack(/*state*/ 444, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoRelExpr4(Nonterminal_relational_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_438(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_439(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_439(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 441;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_shift_expression: return 440;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_440(token_type token, const value_type& value) {
        switch(token) {
        case T_L_SHIFT:
            // shift
            push_stack(/*state*/ 442, value);
            return false;
        case T_R_SHIFT:
            // shift
            push_stack(/*state*/ 444, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoRelExpr5(Nonterminal_relational_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_440(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_441(token_type token, const value_type& value) {
        switch(token) {
        case T_MINUS:
            // shift
            push_stack(/*state*/ 449, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 447, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoShiftExpr1(Nonterminal_shift_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_441(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_442(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_442(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 443;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_443(token_type token, const value_type& value) {
        switch(token) {
        case T_MINUS:
            // shift
            push_stack(/*state*/ 449, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 447, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoShiftExpr2(Nonterminal_shift_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_443(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_444(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_444(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_additive_expression: return 445;
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 446;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_445(token_type token, const value_type& value) {
        switch(token) {
        case T_MINUS:
            // shift
            push_stack(/*state*/ 449, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 447, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_NE:
        case T_OR:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoShiftExpr3(Nonterminal_shift_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_445(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_446(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 452, value);
            return false;
        case T_PERCENT:
            // shift
            push_stack(/*state*/ 456, value);
            return false;
        case T_SLASH:
            // shift
            push_stack(/*state*/ 454, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoAddExpr1(Nonterminal_additive_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_446(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_447(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_447(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 448;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_448(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 452, value);
            return false;
        case T_PERCENT:
            // shift
            push_stack(/*state*/ 456, value);
            return false;
        case T_SLASH:
            // shift
            push_stack(/*state*/ 454, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoAddExpr2(Nonterminal_additive_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_448(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_449(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_449(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 451;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_multiplicative_expression: return 450;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_450(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 452, value);
            return false;
        case T_PERCENT:
            // shift
            push_stack(/*state*/ 456, value);
            return false;
        case T_SLASH:
            // shift
            push_stack(/*state*/ 454, value);
            return false;
        case T_AND:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_XOR:
            // reduce
            return call_0_DoAddExpr3(Nonterminal_additive_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_450(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_451(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_SLASH:
        case T_XOR:
            // reduce
            return call_0_DoMulExpr1(Nonterminal_multiplicative_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_451(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_452(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_452(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 453;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_453(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_SLASH:
        case T_XOR:
            // reduce
            return call_0_DoMulExpr2(Nonterminal_multiplicative_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_453(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_454(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_454(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 455;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_455(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_SLASH:
        case T_XOR:
            // reduce
            return call_0_DoMulExpr3(Nonterminal_multiplicative_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_455(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_456(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_456(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 457;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_457(token_type token, const value_type& value) {
        switch(token) {
        case T_AND:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_MINUS:
        case T_NE:
        case T_OR:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_SEMICOLON:
        case T_SLASH:
        case T_XOR:
            // reduce
            return call_0_DoMulExpr4(Nonterminal_multiplicative_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_457(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_458(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_BRACE:
            // shift
            push_stack(/*state*/ 243, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_458(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 469;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_459(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_459(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 476;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_460(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_460(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 477;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_461(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_461(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 478;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_462(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_462(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 479;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_463(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_463(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 480;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_464(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 97, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_464(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_cast_expression: return 481;
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 465;
        default: assert(0); return false;
        }
    }

    bool state_465(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoCastExpr1(Nonterminal_cast_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_465(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_466(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 458, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_466(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_467(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoCastExpr2(Nonterminal_cast_expression, /*pop*/ 7, 1, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_467(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_468(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoCastExpr3(Nonterminal_cast_expression, /*pop*/ 6, 1, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_468(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_469(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoCastExpr4(Nonterminal_cast_expression, /*pop*/ 4, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_469(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_470(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 367, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_470(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 474;
        default: assert(0); return false;
        }
    }

    bool state_471(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 367, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_471(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 475;
        default: assert(0); return false;
        }
    }

    bool state_472(token_type token, const value_type& value) {
        switch(token) {
        case T_ALIGNOF:
            // shift
            push_stack(/*state*/ 485, value);
            return false;
        case T_AND:
            // shift
            push_stack(/*state*/ 459, value);
            return false;
        case T_ASTERISK:
            // shift
            push_stack(/*state*/ 460, value);
            return false;
        case T_BANG:
            // shift
            push_stack(/*state*/ 464, value);
            return false;
        case T_CONSTANT:
            // shift
            push_stack(/*state*/ 500, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 471, value);
            return false;
        case T_GENERIC:
            // shift
            push_stack(/*state*/ 504, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 499, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 470, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 98, value);
            return false;
        case T_MINUS:
            // shift
            push_stack(/*state*/ 462, value);
            return false;
        case T_PLUS:
            // shift
            push_stack(/*state*/ 461, value);
            return false;
        case T_SIZEOF:
            // shift
            push_stack(/*state*/ 472, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 501, value);
            return false;
        case T_TILDA:
            // shift
            push_stack(/*state*/ 463, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_472(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_postfix_expression: return 473;
        case Nonterminal_primary_expression: return 488;
        case Nonterminal_generic_selection: return 503;
        case Nonterminal_unary_expression: return 482;
        default: assert(0); return false;
        }
    }

    bool state_473(token_type token, const value_type& value) {
        switch(token) {
        case T_ARROW:
            // shift
            push_stack(/*state*/ 495, value);
            return false;
        case T_DEC:
            // shift
            push_stack(/*state*/ 498, value);
            return false;
        case T_DOT:
            // shift
            push_stack(/*state*/ 493, value);
            return false;
        case T_INC:
            // shift
            push_stack(/*state*/ 497, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 366, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 389, value);
            return false;
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr1(Nonterminal_unary_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_473(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_474(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr2(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_474(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_475(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr3(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_475(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_476(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr4(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_476(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_477(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr5(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_477(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_478(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr6(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_478(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_479(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr7(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_479(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_480(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr8(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_480(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_481(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr9(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_481(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_482(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr10(Nonterminal_unary_expression, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_482(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_483(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 484, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_483(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_484(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr11(Nonterminal_unary_expression, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_484(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_485(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 100, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_485(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_486(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 487, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_486(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_487(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DIV_ASSIGN:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_OR:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoUnaryExpr12(Nonterminal_unary_expression, /*pop*/ 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_487(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_488(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr1(Nonterminal_postfix_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_488(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_489(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr2(Nonterminal_postfix_expression, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_489(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_490(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 393, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 491, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_490(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_491(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr3(Nonterminal_postfix_expression, /*pop*/ 4, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_491(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_492(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr4(Nonterminal_postfix_expression, /*pop*/ 3, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_492(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_493(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 494, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_493(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_494(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr5(Nonterminal_postfix_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_494(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_495(token_type token, const value_type& value) {
        switch(token) {
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 496, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_495(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_496(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr6(Nonterminal_postfix_expression, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_496(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_497(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr7(Nonterminal_postfix_expression, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_497(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_498(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPostfixExpr8(Nonterminal_postfix_expression, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_498(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_499(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr1(Nonterminal_primary_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_499(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_500(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr2(Nonterminal_primary_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_500(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_501(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr3(Nonterminal_primary_expression, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_501(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_502(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr4(Nonterminal_primary_expression, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_502(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_503(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoPrimExpr5(Nonterminal_primary_expression, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_503(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_504(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 390, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_504(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_505(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 101, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_505(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_506(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 102, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 507, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_506(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_507(token_type token, const value_type& value) {
        switch(token) {
        case T_ADD_ASSIGN:
        case T_AND:
        case T_AND_ASSIGN:
        case T_ARROW:
        case T_ASSIGN:
        case T_ASTERISK:
        case T_COLON:
        case T_COMMA:
        case T_DEC:
        case T_DIV_ASSIGN:
        case T_DOT:
        case T_EQUAL:
        case T_EXPRESSION:
        case T_GE:
        case T_GT:
        case T_INC:
        case T_LE:
        case T_LT:
        case T_L_AND:
        case T_L_BRACKET:
        case T_L_OR:
        case T_L_PAREN:
        case T_L_SHIFT:
        case T_L_SHIFT_ASSIGN:
        case T_MINUS:
        case T_MOD_ASSIGN:
        case T_MUL_ASSIGN:
        case T_NE:
        case T_OR:
        case T_OR_ASSIGN:
        case T_PERCENT:
        case T_PLUS:
        case T_QUESTION:
        case T_R_BRACE:
        case T_R_BRACKET:
        case T_R_PAREN:
        case T_R_SHIFT:
        case T_R_SHIFT_ASSIGN:
        case T_SEMICOLON:
        case T_SLASH:
        case T_SUB_ASSIGN:
        case T_XOR:
        case T_XOR_ASSIGN:
            // reduce
            return call_0_DoGeneSel1(Nonterminal_generic_selection, /*pop*/ 6, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_507(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_508(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoGeneAssocList1(Nonterminal_generic_assoc_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_508(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_509(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoGeneAssocList2(Nonterminal_generic_assoc_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_509(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_510(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 391, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_510(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_511(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoGeneAssoc1(Nonterminal_generic_association, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_511(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_512(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 392, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_512(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_513(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoGeneAssoc2(Nonterminal_generic_association, /*pop*/ 3, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_513(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_514(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoArgExprList1(Nonterminal_argument_expression_list, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_514(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_515(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
        case T_R_PAREN:
            // reduce
            return call_0_DoArgExprList2(Nonterminal_argument_expression_list, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_515(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_516(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncSpec1(Nonterminal_function_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_516(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_517(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncSpec2(Nonterminal_function_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_517(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_518(token_type token, const value_type& value) {
        switch(token) {
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMMA:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IDENTIFIER:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_R_PAREN:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoFuncSpec3(Nonterminal_function_specifier, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_518(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_519(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 99, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_519(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_520(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 521, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_520(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_521(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_TAGNAME:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoAlignSpec1(Nonterminal_alignment_specifier, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_521(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_522(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 523, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_522(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_523(token_type token, const value_type& value) {
        switch(token) {
        case T_ATOMIC:
        case T_AUTO:
        case T_BOOL:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FORCEINLINE:
        case T_IMAGINARY:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_NORETURN:
        case T_REGISTER:
        case T_RESTRICT:
        case T_SHORT:
        case T_SIGNED:
        case T_STATIC:
        case T_STRUCT:
        case T_TAGNAME:
        case T_THREAD_LOCAL:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
            // reduce
            return call_0_DoAlignSpec2(Nonterminal_alignment_specifier, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_523(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_524(token_type token, const value_type& value) {
        switch(token) {
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 408, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_524(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_525(token_type token, const value_type& value) {
        switch(token) {
        case T_COMMA:
            // shift
            push_stack(/*state*/ 526, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_525(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_526(token_type token, const value_type& value) {
        switch(token) {
        case T_STRING:
            // shift
            push_stack(/*state*/ 527, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_526(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_527(token_type token, const value_type& value) {
        switch(token) {
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 528, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_527(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_528(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // shift
            push_stack(/*state*/ 529, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_528(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_529(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoStaticAssertDecl1(Nonterminal_static_assert_declaration, /*pop*/ 7, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_529(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_530(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 533, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_530(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 542;
        case Nonterminal_asm_operands: return 531;
        default: assert(0); return false;
        }
    }

    bool state_531(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 532, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_531(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 541;
        default: assert(0); return false;
        }
    }

    bool state_532(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // reduce
            return call_0_DoAsmSpec1(Nonterminal_asm_specifier, /*pop*/ 5, 1, 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_532(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_533(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // reduce
            return call_0_DoAsmSpec2(Nonterminal_asm_specifier, /*pop*/ 4, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_533(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_534(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 537, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_534(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 542;
        case Nonterminal_asm_operands: return 535;
        default: assert(0); return false;
        }
    }

    bool state_535(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_R_PAREN:
            // shift
            push_stack(/*state*/ 536, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_535(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 541;
        default: assert(0); return false;
        }
    }

    bool state_536(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // reduce
            return call_0_DoAsmSpec3(Nonterminal_asm_specifier, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_536(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_537(token_type token, const value_type& value) {
        switch(token) {
        case T_SEMICOLON:
            // reduce
            return call_0_DoAsmSpec4(Nonterminal_asm_specifier, /*pop*/ 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_537(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_538(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_538(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 542;
        case Nonterminal_asm_operands: return 539;
        default: assert(0); return false;
        }
    }

    bool state_539(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
            // shift
            push_stack(/*state*/ 546, value);
            return false;
        case T_COMMA:
            // shift
            push_stack(/*state*/ 545, value);
            return false;
        case T_IDENTIFIER:
            // shift
            push_stack(/*state*/ 544, value);
            return false;
        case T_L_BRACKET:
            // shift
            push_stack(/*state*/ 369, value);
            return false;
        case T_L_PAREN:
            // shift
            push_stack(/*state*/ 368, value);
            return false;
        case T_R_BRACE:
            // shift
            push_stack(/*state*/ 540, value);
            return false;
        case T_STRING:
            // shift
            push_stack(/*state*/ 543, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_539(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_asm_operand: return 541;
        default: assert(0); return false;
        }
    }

    bool state_540(token_type token, const value_type& value) {
        switch(token) {
        case eof:
        case T_ALIGNAS:
        case T_ALIGNOF:
        case T_AND:
        case T_ASM:
        case T_ASTERISK:
        case T_ATOMIC:
        case T_AUTO:
        case T_BANG:
        case T_BOOL:
        case T_BREAK:
        case T_CASE:
        case T_CHAR:
        case T_COMPLEX:
        case T_CONST:
        case T_CONSTANT:
        case T_CONTINUE:
        case T_DEC:
        case T_DEFAULT:
        case T_DO:
        case T_DOUBLE:
        case T_ENUM:
        case T_EXTERN:
        case T_FLOAT:
        case T_FOR:
        case T_FORCEINLINE:
        case T_GENERIC:
        case T_GOTO:
        case T_IDENTIFIER:
        case T_IF:
        case T_IMAGINARY:
        case T_INC:
        case T_INLINE:
        case T_INT:
        case T_INT128:
        case T_INT32:
        case T_INT64:
        case T_LONG:
        case T_L_BRACE:
        case T_L_PAREN:
        case T_MINUS:
        case T_NORETURN:
        case T_PLUS:
        case T_REGISTER:
        case T_RESTRICT:
        case T_RETURN:
        case T_R_BRACE:
        case T_SEMICOLON:
        case T_SHORT:
        case T_SIGNED:
        case T_SIZEOF:
        case T_STATIC:
        case T_STATIC_ASSERT:
        case T_STRING:
        case T_STRUCT:
        case T_SWITCH:
        case T_THREAD_LOCAL:
        case T_TILDA:
        case T_TYPEDEF:
        case T_TYPEDEF_NAME:
        case T_UNION:
        case T_UNSIGNED:
        case T_VOID:
        case T_VOLATILE:
        case T_W64:
        case T_WHILE:
            // reduce
            return call_0_DoAsmBlock1(Nonterminal_asm_block, /*pop*/ 4, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_540(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_541(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperands1(Nonterminal_asm_operands, /*pop*/ 2, 0, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_541(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_542(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperands2(Nonterminal_asm_operands, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_542(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_543(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand1(Nonterminal_asm_operand, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_543(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_544(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand2(Nonterminal_asm_operand, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_544(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_545(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand3(Nonterminal_asm_operand, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_545(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_546(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand4(Nonterminal_asm_operand, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_546(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_547(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand5(Nonterminal_asm_operand, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_547(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_548(token_type token, const value_type& value) {
        switch(token) {
        case T_COLON:
        case T_COMMA:
        case T_IDENTIFIER:
        case T_L_BRACKET:
        case T_L_PAREN:
        case T_R_BRACE:
        case T_R_PAREN:
        case T_STRING:
            // reduce
            return call_0_DoAsmOperand6(Nonterminal_asm_operand, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_548(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    const table_entry* entry(int n) const {
        static const table_entry entries[] = {
            { &Parser::state_0, &Parser::gotof_0, false },
            { &Parser::state_1, &Parser::gotof_1, false },
            { &Parser::state_2, &Parser::gotof_2, false },
            { &Parser::state_3, &Parser::gotof_3, false },
            { &Parser::state_4, &Parser::gotof_4, false },
            { &Parser::state_5, &Parser::gotof_5, false },
            { &Parser::state_6, &Parser::gotof_6, false },
            { &Parser::state_7, &Parser::gotof_7, false },
            { &Parser::state_8, &Parser::gotof_8, false },
            { &Parser::state_9, &Parser::gotof_9, false },
            { &Parser::state_10, &Parser::gotof_10, false },
            { &Parser::state_11, &Parser::gotof_11, false },
            { &Parser::state_12, &Parser::gotof_12, false },
            { &Parser::state_13, &Parser::gotof_13, false },
            { &Parser::state_14, &Parser::gotof_14, false },
            { &Parser::state_15, &Parser::gotof_15, false },
            { &Parser::state_16, &Parser::gotof_16, false },
            { &Parser::state_17, &Parser::gotof_17, false },
            { &Parser::state_18, &Parser::gotof_18, false },
            { &Parser::state_19, &Parser::gotof_19, false },
            { &Parser::state_20, &Parser::gotof_20, false },
            { &Parser::state_21, &Parser::gotof_21, false },
            { &Parser::state_22, &Parser::gotof_22, false },
            { &Parser::state_23, &Parser::gotof_23, false },
            { &Parser::state_24, &Parser::gotof_24, false },
            { &Parser::state_25, &Parser::gotof_25, false },
            { &Parser::state_26, &Parser::gotof_26, false },
            { &Parser::state_27, &Parser::gotof_27, false },
            { &Parser::state_28, &Parser::gotof_28, false },
            { &Parser::state_29, &Parser::gotof_29, false },
            { &Parser::state_30, &Parser::gotof_30, false },
            { &Parser::state_31, &Parser::gotof_31, false },
            { &Parser::state_32, &Parser::gotof_32, false },
            { &Parser::state_33, &Parser::gotof_33, false },
            { &Parser::state_34, &Parser::gotof_34, false },
            { &Parser::state_35, &Parser::gotof_35, false },
            { &Parser::state_36, &Parser::gotof_36, false },
            { &Parser::state_37, &Parser::gotof_37, false },
            { &Parser::state_38, &Parser::gotof_38, false },
            { &Parser::state_39, &Parser::gotof_39, false },
            { &Parser::state_40, &Parser::gotof_40, false },
            { &Parser::state_41, &Parser::gotof_41, false },
            { &Parser::state_42, &Parser::gotof_42, false },
            { &Parser::state_43, &Parser::gotof_43, false },
            { &Parser::state_44, &Parser::gotof_44, false },
            { &Parser::state_45, &Parser::gotof_45, false },
            { &Parser::state_46, &Parser::gotof_46, false },
            { &Parser::state_47, &Parser::gotof_47, false },
            { &Parser::state_48, &Parser::gotof_48, false },
            { &Parser::state_49, &Parser::gotof_49, false },
            { &Parser::state_50, &Parser::gotof_50, false },
            { &Parser::state_51, &Parser::gotof_51, false },
            { &Parser::state_52, &Parser::gotof_52, false },
            { &Parser::state_53, &Parser::gotof_53, false },
            { &Parser::state_54, &Parser::gotof_54, false },
            { &Parser::state_55, &Parser::gotof_55, false },
            { &Parser::state_56, &Parser::gotof_56, false },
            { &Parser::state_57, &Parser::gotof_57, false },
            { &Parser::state_58, &Parser::gotof_58, false },
            { &Parser::state_59, &Parser::gotof_59, false },
            { &Parser::state_60, &Parser::gotof_60, false },
            { &Parser::state_61, &Parser::gotof_61, false },
            { &Parser::state_62, &Parser::gotof_62, false },
            { &Parser::state_63, &Parser::gotof_63, false },
            { &Parser::state_64, &Parser::gotof_64, false },
            { &Parser::state_65, &Parser::gotof_65, false },
            { &Parser::state_66, &Parser::gotof_66, false },
            { &Parser::state_67, &Parser::gotof_67, false },
            { &Parser::state_68, &Parser::gotof_68, false },
            { &Parser::state_69, &Parser::gotof_69, false },
            { &Parser::state_70, &Parser::gotof_70, false },
            { &Parser::state_71, &Parser::gotof_71, false },
            { &Parser::state_72, &Parser::gotof_72, false },
            { &Parser::state_73, &Parser::gotof_73, false },
            { &Parser::state_74, &Parser::gotof_74, false },
            { &Parser::state_75, &Parser::gotof_75, false },
            { &Parser::state_76, &Parser::gotof_76, false },
            { &Parser::state_77, &Parser::gotof_77, false },
            { &Parser::state_78, &Parser::gotof_78, false },
            { &Parser::state_79, &Parser::gotof_79, false },
            { &Parser::state_80, &Parser::gotof_80, false },
            { &Parser::state_81, &Parser::gotof_81, false },
            { &Parser::state_82, &Parser::gotof_82, false },
            { &Parser::state_83, &Parser::gotof_83, false },
            { &Parser::state_84, &Parser::gotof_84, false },
            { &Parser::state_85, &Parser::gotof_85, false },
            { &Parser::state_86, &Parser::gotof_86, false },
            { &Parser::state_87, &Parser::gotof_87, false },
            { &Parser::state_88, &Parser::gotof_88, false },
            { &Parser::state_89, &Parser::gotof_89, false },
            { &Parser::state_90, &Parser::gotof_90, false },
            { &Parser::state_91, &Parser::gotof_91, false },
            { &Parser::state_92, &Parser::gotof_92, false },
            { &Parser::state_93, &Parser::gotof_93, false },
            { &Parser::state_94, &Parser::gotof_94, false },
            { &Parser::state_95, &Parser::gotof_95, false },
            { &Parser::state_96, &Parser::gotof_96, false },
            { &Parser::state_97, &Parser::gotof_97, false },
            { &Parser::state_98, &Parser::gotof_98, false },
            { &Parser::state_99, &Parser::gotof_99, false },
            { &Parser::state_100, &Parser::gotof_100, false },
            { &Parser::state_101, &Parser::gotof_101, false },
            { &Parser::state_102, &Parser::gotof_102, false },
            { &Parser::state_103, &Parser::gotof_103, false },
            { &Parser::state_104, &Parser::gotof_104, false },
            { &Parser::state_105, &Parser::gotof_105, false },
            { &Parser::state_106, &Parser::gotof_106, false },
            { &Parser::state_107, &Parser::gotof_107, false },
            { &Parser::state_108, &Parser::gotof_108, false },
            { &Parser::state_109, &Parser::gotof_109, false },
            { &Parser::state_110, &Parser::gotof_110, false },
            { &Parser::state_111, &Parser::gotof_111, false },
            { &Parser::state_112, &Parser::gotof_112, false },
            { &Parser::state_113, &Parser::gotof_113, false },
            { &Parser::state_114, &Parser::gotof_114, false },
            { &Parser::state_115, &Parser::gotof_115, false },
            { &Parser::state_116, &Parser::gotof_116, false },
            { &Parser::state_117, &Parser::gotof_117, false },
            { &Parser::state_118, &Parser::gotof_118, false },
            { &Parser::state_119, &Parser::gotof_119, false },
            { &Parser::state_120, &Parser::gotof_120, false },
            { &Parser::state_121, &Parser::gotof_121, false },
            { &Parser::state_122, &Parser::gotof_122, false },
            { &Parser::state_123, &Parser::gotof_123, false },
            { &Parser::state_124, &Parser::gotof_124, false },
            { &Parser::state_125, &Parser::gotof_125, false },
            { &Parser::state_126, &Parser::gotof_126, false },
            { &Parser::state_127, &Parser::gotof_127, false },
            { &Parser::state_128, &Parser::gotof_128, false },
            { &Parser::state_129, &Parser::gotof_129, false },
            { &Parser::state_130, &Parser::gotof_130, false },
            { &Parser::state_131, &Parser::gotof_131, false },
            { &Parser::state_132, &Parser::gotof_132, false },
            { &Parser::state_133, &Parser::gotof_133, false },
            { &Parser::state_134, &Parser::gotof_134, false },
            { &Parser::state_135, &Parser::gotof_135, false },
            { &Parser::state_136, &Parser::gotof_136, false },
            { &Parser::state_137, &Parser::gotof_137, false },
            { &Parser::state_138, &Parser::gotof_138, false },
            { &Parser::state_139, &Parser::gotof_139, false },
            { &Parser::state_140, &Parser::gotof_140, false },
            { &Parser::state_141, &Parser::gotof_141, false },
            { &Parser::state_142, &Parser::gotof_142, false },
            { &Parser::state_143, &Parser::gotof_143, false },
            { &Parser::state_144, &Parser::gotof_144, false },
            { &Parser::state_145, &Parser::gotof_145, false },
            { &Parser::state_146, &Parser::gotof_146, false },
            { &Parser::state_147, &Parser::gotof_147, false },
            { &Parser::state_148, &Parser::gotof_148, false },
            { &Parser::state_149, &Parser::gotof_149, false },
            { &Parser::state_150, &Parser::gotof_150, false },
            { &Parser::state_151, &Parser::gotof_151, false },
            { &Parser::state_152, &Parser::gotof_152, false },
            { &Parser::state_153, &Parser::gotof_153, false },
            { &Parser::state_154, &Parser::gotof_154, false },
            { &Parser::state_155, &Parser::gotof_155, false },
            { &Parser::state_156, &Parser::gotof_156, false },
            { &Parser::state_157, &Parser::gotof_157, false },
            { &Parser::state_158, &Parser::gotof_158, false },
            { &Parser::state_159, &Parser::gotof_159, false },
            { &Parser::state_160, &Parser::gotof_160, false },
            { &Parser::state_161, &Parser::gotof_161, false },
            { &Parser::state_162, &Parser::gotof_162, false },
            { &Parser::state_163, &Parser::gotof_163, false },
            { &Parser::state_164, &Parser::gotof_164, false },
            { &Parser::state_165, &Parser::gotof_165, false },
            { &Parser::state_166, &Parser::gotof_166, false },
            { &Parser::state_167, &Parser::gotof_167, false },
            { &Parser::state_168, &Parser::gotof_168, false },
            { &Parser::state_169, &Parser::gotof_169, false },
            { &Parser::state_170, &Parser::gotof_170, false },
            { &Parser::state_171, &Parser::gotof_171, false },
            { &Parser::state_172, &Parser::gotof_172, false },
            { &Parser::state_173, &Parser::gotof_173, false },
            { &Parser::state_174, &Parser::gotof_174, false },
            { &Parser::state_175, &Parser::gotof_175, false },
            { &Parser::state_176, &Parser::gotof_176, false },
            { &Parser::state_177, &Parser::gotof_177, false },
            { &Parser::state_178, &Parser::gotof_178, false },
            { &Parser::state_179, &Parser::gotof_179, false },
            { &Parser::state_180, &Parser::gotof_180, false },
            { &Parser::state_181, &Parser::gotof_181, false },
            { &Parser::state_182, &Parser::gotof_182, false },
            { &Parser::state_183, &Parser::gotof_183, false },
            { &Parser::state_184, &Parser::gotof_184, false },
            { &Parser::state_185, &Parser::gotof_185, false },
            { &Parser::state_186, &Parser::gotof_186, false },
            { &Parser::state_187, &Parser::gotof_187, false },
            { &Parser::state_188, &Parser::gotof_188, false },
            { &Parser::state_189, &Parser::gotof_189, false },
            { &Parser::state_190, &Parser::gotof_190, false },
            { &Parser::state_191, &Parser::gotof_191, false },
            { &Parser::state_192, &Parser::gotof_192, false },
            { &Parser::state_193, &Parser::gotof_193, false },
            { &Parser::state_194, &Parser::gotof_194, false },
            { &Parser::state_195, &Parser::gotof_195, false },
            { &Parser::state_196, &Parser::gotof_196, false },
            { &Parser::state_197, &Parser::gotof_197, false },
            { &Parser::state_198, &Parser::gotof_198, false },
            { &Parser::state_199, &Parser::gotof_199, false },
            { &Parser::state_200, &Parser::gotof_200, false },
            { &Parser::state_201, &Parser::gotof_201, false },
            { &Parser::state_202, &Parser::gotof_202, false },
            { &Parser::state_203, &Parser::gotof_203, false },
            { &Parser::state_204, &Parser::gotof_204, false },
            { &Parser::state_205, &Parser::gotof_205, false },
            { &Parser::state_206, &Parser::gotof_206, false },
            { &Parser::state_207, &Parser::gotof_207, false },
            { &Parser::state_208, &Parser::gotof_208, false },
            { &Parser::state_209, &Parser::gotof_209, false },
            { &Parser::state_210, &Parser::gotof_210, false },
            { &Parser::state_211, &Parser::gotof_211, false },
            { &Parser::state_212, &Parser::gotof_212, false },
            { &Parser::state_213, &Parser::gotof_213, false },
            { &Parser::state_214, &Parser::gotof_214, false },
            { &Parser::state_215, &Parser::gotof_215, false },
            { &Parser::state_216, &Parser::gotof_216, false },
            { &Parser::state_217, &Parser::gotof_217, false },
            { &Parser::state_218, &Parser::gotof_218, false },
            { &Parser::state_219, &Parser::gotof_219, false },
            { &Parser::state_220, &Parser::gotof_220, false },
            { &Parser::state_221, &Parser::gotof_221, false },
            { &Parser::state_222, &Parser::gotof_222, false },
            { &Parser::state_223, &Parser::gotof_223, false },
            { &Parser::state_224, &Parser::gotof_224, false },
            { &Parser::state_225, &Parser::gotof_225, false },
            { &Parser::state_226, &Parser::gotof_226, false },
            { &Parser::state_227, &Parser::gotof_227, false },
            { &Parser::state_228, &Parser::gotof_228, false },
            { &Parser::state_229, &Parser::gotof_229, false },
            { &Parser::state_230, &Parser::gotof_230, false },
            { &Parser::state_231, &Parser::gotof_231, false },
            { &Parser::state_232, &Parser::gotof_232, false },
            { &Parser::state_233, &Parser::gotof_233, false },
            { &Parser::state_234, &Parser::gotof_234, false },
            { &Parser::state_235, &Parser::gotof_235, false },
            { &Parser::state_236, &Parser::gotof_236, false },
            { &Parser::state_237, &Parser::gotof_237, false },
            { &Parser::state_238, &Parser::gotof_238, false },
            { &Parser::state_239, &Parser::gotof_239, false },
            { &Parser::state_240, &Parser::gotof_240, false },
            { &Parser::state_241, &Parser::gotof_241, false },
            { &Parser::state_242, &Parser::gotof_242, false },
            { &Parser::state_243, &Parser::gotof_243, false },
            { &Parser::state_244, &Parser::gotof_244, false },
            { &Parser::state_245, &Parser::gotof_245, false },
            { &Parser::state_246, &Parser::gotof_246, false },
            { &Parser::state_247, &Parser::gotof_247, false },
            { &Parser::state_248, &Parser::gotof_248, false },
            { &Parser::state_249, &Parser::gotof_249, false },
            { &Parser::state_250, &Parser::gotof_250, false },
            { &Parser::state_251, &Parser::gotof_251, false },
            { &Parser::state_252, &Parser::gotof_252, false },
            { &Parser::state_253, &Parser::gotof_253, false },
            { &Parser::state_254, &Parser::gotof_254, false },
            { &Parser::state_255, &Parser::gotof_255, false },
            { &Parser::state_256, &Parser::gotof_256, false },
            { &Parser::state_257, &Parser::gotof_257, false },
            { &Parser::state_258, &Parser::gotof_258, false },
            { &Parser::state_259, &Parser::gotof_259, false },
            { &Parser::state_260, &Parser::gotof_260, false },
            { &Parser::state_261, &Parser::gotof_261, false },
            { &Parser::state_262, &Parser::gotof_262, false },
            { &Parser::state_263, &Parser::gotof_263, false },
            { &Parser::state_264, &Parser::gotof_264, false },
            { &Parser::state_265, &Parser::gotof_265, false },
            { &Parser::state_266, &Parser::gotof_266, false },
            { &Parser::state_267, &Parser::gotof_267, false },
            { &Parser::state_268, &Parser::gotof_268, false },
            { &Parser::state_269, &Parser::gotof_269, false },
            { &Parser::state_270, &Parser::gotof_270, false },
            { &Parser::state_271, &Parser::gotof_271, false },
            { &Parser::state_272, &Parser::gotof_272, false },
            { &Parser::state_273, &Parser::gotof_273, false },
            { &Parser::state_274, &Parser::gotof_274, false },
            { &Parser::state_275, &Parser::gotof_275, false },
            { &Parser::state_276, &Parser::gotof_276, false },
            { &Parser::state_277, &Parser::gotof_277, false },
            { &Parser::state_278, &Parser::gotof_278, false },
            { &Parser::state_279, &Parser::gotof_279, false },
            { &Parser::state_280, &Parser::gotof_280, false },
            { &Parser::state_281, &Parser::gotof_281, false },
            { &Parser::state_282, &Parser::gotof_282, false },
            { &Parser::state_283, &Parser::gotof_283, false },
            { &Parser::state_284, &Parser::gotof_284, false },
            { &Parser::state_285, &Parser::gotof_285, false },
            { &Parser::state_286, &Parser::gotof_286, false },
            { &Parser::state_287, &Parser::gotof_287, false },
            { &Parser::state_288, &Parser::gotof_288, false },
            { &Parser::state_289, &Parser::gotof_289, false },
            { &Parser::state_290, &Parser::gotof_290, false },
            { &Parser::state_291, &Parser::gotof_291, false },
            { &Parser::state_292, &Parser::gotof_292, false },
            { &Parser::state_293, &Parser::gotof_293, false },
            { &Parser::state_294, &Parser::gotof_294, false },
            { &Parser::state_295, &Parser::gotof_295, false },
            { &Parser::state_296, &Parser::gotof_296, false },
            { &Parser::state_297, &Parser::gotof_297, false },
            { &Parser::state_298, &Parser::gotof_298, false },
            { &Parser::state_299, &Parser::gotof_299, false },
            { &Parser::state_300, &Parser::gotof_300, false },
            { &Parser::state_301, &Parser::gotof_301, false },
            { &Parser::state_302, &Parser::gotof_302, false },
            { &Parser::state_303, &Parser::gotof_303, false },
            { &Parser::state_304, &Parser::gotof_304, false },
            { &Parser::state_305, &Parser::gotof_305, false },
            { &Parser::state_306, &Parser::gotof_306, false },
            { &Parser::state_307, &Parser::gotof_307, false },
            { &Parser::state_308, &Parser::gotof_308, false },
            { &Parser::state_309, &Parser::gotof_309, false },
            { &Parser::state_310, &Parser::gotof_310, false },
            { &Parser::state_311, &Parser::gotof_311, false },
            { &Parser::state_312, &Parser::gotof_312, false },
            { &Parser::state_313, &Parser::gotof_313, false },
            { &Parser::state_314, &Parser::gotof_314, false },
            { &Parser::state_315, &Parser::gotof_315, false },
            { &Parser::state_316, &Parser::gotof_316, false },
            { &Parser::state_317, &Parser::gotof_317, false },
            { &Parser::state_318, &Parser::gotof_318, false },
            { &Parser::state_319, &Parser::gotof_319, false },
            { &Parser::state_320, &Parser::gotof_320, false },
            { &Parser::state_321, &Parser::gotof_321, false },
            { &Parser::state_322, &Parser::gotof_322, false },
            { &Parser::state_323, &Parser::gotof_323, false },
            { &Parser::state_324, &Parser::gotof_324, false },
            { &Parser::state_325, &Parser::gotof_325, false },
            { &Parser::state_326, &Parser::gotof_326, false },
            { &Parser::state_327, &Parser::gotof_327, false },
            { &Parser::state_328, &Parser::gotof_328, false },
            { &Parser::state_329, &Parser::gotof_329, false },
            { &Parser::state_330, &Parser::gotof_330, false },
            { &Parser::state_331, &Parser::gotof_331, false },
            { &Parser::state_332, &Parser::gotof_332, false },
            { &Parser::state_333, &Parser::gotof_333, false },
            { &Parser::state_334, &Parser::gotof_334, false },
            { &Parser::state_335, &Parser::gotof_335, false },
            { &Parser::state_336, &Parser::gotof_336, false },
            { &Parser::state_337, &Parser::gotof_337, false },
            { &Parser::state_338, &Parser::gotof_338, false },
            { &Parser::state_339, &Parser::gotof_339, false },
            { &Parser::state_340, &Parser::gotof_340, false },
            { &Parser::state_341, &Parser::gotof_341, false },
            { &Parser::state_342, &Parser::gotof_342, false },
            { &Parser::state_343, &Parser::gotof_343, false },
            { &Parser::state_344, &Parser::gotof_344, false },
            { &Parser::state_345, &Parser::gotof_345, false },
            { &Parser::state_346, &Parser::gotof_346, false },
            { &Parser::state_347, &Parser::gotof_347, false },
            { &Parser::state_348, &Parser::gotof_348, false },
            { &Parser::state_349, &Parser::gotof_349, false },
            { &Parser::state_350, &Parser::gotof_350, false },
            { &Parser::state_351, &Parser::gotof_351, false },
            { &Parser::state_352, &Parser::gotof_352, false },
            { &Parser::state_353, &Parser::gotof_353, false },
            { &Parser::state_354, &Parser::gotof_354, false },
            { &Parser::state_355, &Parser::gotof_355, false },
            { &Parser::state_356, &Parser::gotof_356, false },
            { &Parser::state_357, &Parser::gotof_357, false },
            { &Parser::state_358, &Parser::gotof_358, false },
            { &Parser::state_359, &Parser::gotof_359, false },
            { &Parser::state_360, &Parser::gotof_360, false },
            { &Parser::state_361, &Parser::gotof_361, false },
            { &Parser::state_362, &Parser::gotof_362, false },
            { &Parser::state_363, &Parser::gotof_363, false },
            { &Parser::state_364, &Parser::gotof_364, false },
            { &Parser::state_365, &Parser::gotof_365, false },
            { &Parser::state_366, &Parser::gotof_366, false },
            { &Parser::state_367, &Parser::gotof_367, false },
            { &Parser::state_368, &Parser::gotof_368, false },
            { &Parser::state_369, &Parser::gotof_369, false },
            { &Parser::state_370, &Parser::gotof_370, false },
            { &Parser::state_371, &Parser::gotof_371, false },
            { &Parser::state_372, &Parser::gotof_372, false },
            { &Parser::state_373, &Parser::gotof_373, false },
            { &Parser::state_374, &Parser::gotof_374, false },
            { &Parser::state_375, &Parser::gotof_375, false },
            { &Parser::state_376, &Parser::gotof_376, false },
            { &Parser::state_377, &Parser::gotof_377, false },
            { &Parser::state_378, &Parser::gotof_378, false },
            { &Parser::state_379, &Parser::gotof_379, false },
            { &Parser::state_380, &Parser::gotof_380, false },
            { &Parser::state_381, &Parser::gotof_381, false },
            { &Parser::state_382, &Parser::gotof_382, false },
            { &Parser::state_383, &Parser::gotof_383, false },
            { &Parser::state_384, &Parser::gotof_384, false },
            { &Parser::state_385, &Parser::gotof_385, false },
            { &Parser::state_386, &Parser::gotof_386, false },
            { &Parser::state_387, &Parser::gotof_387, false },
            { &Parser::state_388, &Parser::gotof_388, false },
            { &Parser::state_389, &Parser::gotof_389, false },
            { &Parser::state_390, &Parser::gotof_390, false },
            { &Parser::state_391, &Parser::gotof_391, false },
            { &Parser::state_392, &Parser::gotof_392, false },
            { &Parser::state_393, &Parser::gotof_393, false },
            { &Parser::state_394, &Parser::gotof_394, false },
            { &Parser::state_395, &Parser::gotof_395, false },
            { &Parser::state_396, &Parser::gotof_396, false },
            { &Parser::state_397, &Parser::gotof_397, false },
            { &Parser::state_398, &Parser::gotof_398, false },
            { &Parser::state_399, &Parser::gotof_399, false },
            { &Parser::state_400, &Parser::gotof_400, false },
            { &Parser::state_401, &Parser::gotof_401, false },
            { &Parser::state_402, &Parser::gotof_402, false },
            { &Parser::state_403, &Parser::gotof_403, false },
            { &Parser::state_404, &Parser::gotof_404, false },
            { &Parser::state_405, &Parser::gotof_405, false },
            { &Parser::state_406, &Parser::gotof_406, false },
            { &Parser::state_407, &Parser::gotof_407, false },
            { &Parser::state_408, &Parser::gotof_408, false },
            { &Parser::state_409, &Parser::gotof_409, false },
            { &Parser::state_410, &Parser::gotof_410, false },
            { &Parser::state_411, &Parser::gotof_411, false },
            { &Parser::state_412, &Parser::gotof_412, false },
            { &Parser::state_413, &Parser::gotof_413, false },
            { &Parser::state_414, &Parser::gotof_414, false },
            { &Parser::state_415, &Parser::gotof_415, false },
            { &Parser::state_416, &Parser::gotof_416, false },
            { &Parser::state_417, &Parser::gotof_417, false },
            { &Parser::state_418, &Parser::gotof_418, false },
            { &Parser::state_419, &Parser::gotof_419, false },
            { &Parser::state_420, &Parser::gotof_420, false },
            { &Parser::state_421, &Parser::gotof_421, false },
            { &Parser::state_422, &Parser::gotof_422, false },
            { &Parser::state_423, &Parser::gotof_423, false },
            { &Parser::state_424, &Parser::gotof_424, false },
            { &Parser::state_425, &Parser::gotof_425, false },
            { &Parser::state_426, &Parser::gotof_426, false },
            { &Parser::state_427, &Parser::gotof_427, false },
            { &Parser::state_428, &Parser::gotof_428, false },
            { &Parser::state_429, &Parser::gotof_429, false },
            { &Parser::state_430, &Parser::gotof_430, false },
            { &Parser::state_431, &Parser::gotof_431, false },
            { &Parser::state_432, &Parser::gotof_432, false },
            { &Parser::state_433, &Parser::gotof_433, false },
            { &Parser::state_434, &Parser::gotof_434, false },
            { &Parser::state_435, &Parser::gotof_435, false },
            { &Parser::state_436, &Parser::gotof_436, false },
            { &Parser::state_437, &Parser::gotof_437, false },
            { &Parser::state_438, &Parser::gotof_438, false },
            { &Parser::state_439, &Parser::gotof_439, false },
            { &Parser::state_440, &Parser::gotof_440, false },
            { &Parser::state_441, &Parser::gotof_441, false },
            { &Parser::state_442, &Parser::gotof_442, false },
            { &Parser::state_443, &Parser::gotof_443, false },
            { &Parser::state_444, &Parser::gotof_444, false },
            { &Parser::state_445, &Parser::gotof_445, false },
            { &Parser::state_446, &Parser::gotof_446, false },
            { &Parser::state_447, &Parser::gotof_447, false },
            { &Parser::state_448, &Parser::gotof_448, false },
            { &Parser::state_449, &Parser::gotof_449, false },
            { &Parser::state_450, &Parser::gotof_450, false },
            { &Parser::state_451, &Parser::gotof_451, false },
            { &Parser::state_452, &Parser::gotof_452, false },
            { &Parser::state_453, &Parser::gotof_453, false },
            { &Parser::state_454, &Parser::gotof_454, false },
            { &Parser::state_455, &Parser::gotof_455, false },
            { &Parser::state_456, &Parser::gotof_456, false },
            { &Parser::state_457, &Parser::gotof_457, false },
            { &Parser::state_458, &Parser::gotof_458, false },
            { &Parser::state_459, &Parser::gotof_459, false },
            { &Parser::state_460, &Parser::gotof_460, false },
            { &Parser::state_461, &Parser::gotof_461, false },
            { &Parser::state_462, &Parser::gotof_462, false },
            { &Parser::state_463, &Parser::gotof_463, false },
            { &Parser::state_464, &Parser::gotof_464, false },
            { &Parser::state_465, &Parser::gotof_465, false },
            { &Parser::state_466, &Parser::gotof_466, false },
            { &Parser::state_467, &Parser::gotof_467, false },
            { &Parser::state_468, &Parser::gotof_468, false },
            { &Parser::state_469, &Parser::gotof_469, false },
            { &Parser::state_470, &Parser::gotof_470, false },
            { &Parser::state_471, &Parser::gotof_471, false },
            { &Parser::state_472, &Parser::gotof_472, false },
            { &Parser::state_473, &Parser::gotof_473, false },
            { &Parser::state_474, &Parser::gotof_474, false },
            { &Parser::state_475, &Parser::gotof_475, false },
            { &Parser::state_476, &Parser::gotof_476, false },
            { &Parser::state_477, &Parser::gotof_477, false },
            { &Parser::state_478, &Parser::gotof_478, false },
            { &Parser::state_479, &Parser::gotof_479, false },
            { &Parser::state_480, &Parser::gotof_480, false },
            { &Parser::state_481, &Parser::gotof_481, false },
            { &Parser::state_482, &Parser::gotof_482, false },
            { &Parser::state_483, &Parser::gotof_483, false },
            { &Parser::state_484, &Parser::gotof_484, false },
            { &Parser::state_485, &Parser::gotof_485, false },
            { &Parser::state_486, &Parser::gotof_486, false },
            { &Parser::state_487, &Parser::gotof_487, false },
            { &Parser::state_488, &Parser::gotof_488, false },
            { &Parser::state_489, &Parser::gotof_489, false },
            { &Parser::state_490, &Parser::gotof_490, false },
            { &Parser::state_491, &Parser::gotof_491, false },
            { &Parser::state_492, &Parser::gotof_492, false },
            { &Parser::state_493, &Parser::gotof_493, false },
            { &Parser::state_494, &Parser::gotof_494, false },
            { &Parser::state_495, &Parser::gotof_495, false },
            { &Parser::state_496, &Parser::gotof_496, false },
            { &Parser::state_497, &Parser::gotof_497, false },
            { &Parser::state_498, &Parser::gotof_498, false },
            { &Parser::state_499, &Parser::gotof_499, false },
            { &Parser::state_500, &Parser::gotof_500, false },
            { &Parser::state_501, &Parser::gotof_501, false },
            { &Parser::state_502, &Parser::gotof_502, false },
            { &Parser::state_503, &Parser::gotof_503, false },
            { &Parser::state_504, &Parser::gotof_504, false },
            { &Parser::state_505, &Parser::gotof_505, false },
            { &Parser::state_506, &Parser::gotof_506, false },
            { &Parser::state_507, &Parser::gotof_507, false },
            { &Parser::state_508, &Parser::gotof_508, false },
            { &Parser::state_509, &Parser::gotof_509, false },
            { &Parser::state_510, &Parser::gotof_510, false },
            { &Parser::state_511, &Parser::gotof_511, false },
            { &Parser::state_512, &Parser::gotof_512, false },
            { &Parser::state_513, &Parser::gotof_513, false },
            { &Parser::state_514, &Parser::gotof_514, false },
            { &Parser::state_515, &Parser::gotof_515, false },
            { &Parser::state_516, &Parser::gotof_516, false },
            { &Parser::state_517, &Parser::gotof_517, false },
            { &Parser::state_518, &Parser::gotof_518, false },
            { &Parser::state_519, &Parser::gotof_519, false },
            { &Parser::state_520, &Parser::gotof_520, false },
            { &Parser::state_521, &Parser::gotof_521, false },
            { &Parser::state_522, &Parser::gotof_522, false },
            { &Parser::state_523, &Parser::gotof_523, false },
            { &Parser::state_524, &Parser::gotof_524, false },
            { &Parser::state_525, &Parser::gotof_525, false },
            { &Parser::state_526, &Parser::gotof_526, false },
            { &Parser::state_527, &Parser::gotof_527, false },
            { &Parser::state_528, &Parser::gotof_528, false },
            { &Parser::state_529, &Parser::gotof_529, false },
            { &Parser::state_530, &Parser::gotof_530, false },
            { &Parser::state_531, &Parser::gotof_531, false },
            { &Parser::state_532, &Parser::gotof_532, false },
            { &Parser::state_533, &Parser::gotof_533, false },
            { &Parser::state_534, &Parser::gotof_534, false },
            { &Parser::state_535, &Parser::gotof_535, false },
            { &Parser::state_536, &Parser::gotof_536, false },
            { &Parser::state_537, &Parser::gotof_537, false },
            { &Parser::state_538, &Parser::gotof_538, false },
            { &Parser::state_539, &Parser::gotof_539, false },
            { &Parser::state_540, &Parser::gotof_540, false },
            { &Parser::state_541, &Parser::gotof_541, false },
            { &Parser::state_542, &Parser::gotof_542, false },
            { &Parser::state_543, &Parser::gotof_543, false },
            { &Parser::state_544, &Parser::gotof_544, false },
            { &Parser::state_545, &Parser::gotof_545, false },
            { &Parser::state_546, &Parser::gotof_546, false },
            { &Parser::state_547, &Parser::gotof_547, false },
            { &Parser::state_548, &Parser::gotof_548, false },
        };
        return &entries[n];
    }

};

} // namespace cparser

#endif // #ifndef CPARSER_H_

